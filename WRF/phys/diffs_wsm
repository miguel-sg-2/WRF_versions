1,4c1
< #ifdef _ACCEL
< #  include "module_mp_wsm3_accel.F"
< #else
< #if ( RWORDSIZE == 4 )
---
> #if ( (defined(wrfmodel) ) && ( RWORDSIZE == 4 ) ) || ( ( defined(mpas) ) && defined(SINGLE_PRECISION) )
12c9
< MODULE module_mp_wsm3
---
> MODULE module_mp_wsm6
13a11
>    USE module_mp_radar
16a15
> !   REAL, PARAMETER, PRIVATE :: n0g = 4.e6         ! intercept parameter graupel ! set later with hail_opt
24a24,26
> !   REAL, PARAMETER, PRIVATE :: avtg = 330.        ! a constant for terminal velocity of graupel ! set later with hail_opt
> !   REAL, PARAMETER, PRIVATE :: bvtg = 0.8         ! a constant for terminal velocity of graupel ! set later with hail_opt
> !   REAL, PARAMETER, PRIVATE :: deng = 500.        ! density of graupel ! set later with hail_opt
28c30
<    REAL, PARAMETER, PRIVATE :: lamdagmax = 6.e4   ! limited maximum value for slope parameter of graupel
---
> !   REAL, PARAMETER, PRIVATE :: lamdagmax = 6.e4   ! limited maximum value for slope parameter of graupel
31c33
<    REAL, PARAMETER, PRIVATE :: n0s = 2.e6         ! temperature dependent intercept parameter snow 
---
>    REAL, PARAMETER, PRIVATE :: n0s = 2.e6         ! temperature dependent intercept parameter snow
32a35,36
>    REAL, PARAMETER, PRIVATE :: pfrz1 = 100.       ! constant in Biggs freezing
>    REAL, PARAMETER, PRIVATE :: pfrz2 = 0.66       ! constant in Biggs freezing
33a38,40
>    REAL, PARAMETER, PRIVATE :: eacrc = 1.0        ! Snow/cloud-water collection efficiency
>    REAL, PARAMETER, PRIVATE :: dens  =  100.0     ! Density of snow
>    REAL, PARAMETER, PRIVATE :: qs0   =  6.e-4     ! threshold amount for aggretion to occur
35c42
<              qc0, qck1, pidnc,                        &  
---
>              qc0, qck1, pidnc,                        & 
38c45,46
<              precr1,precr2,xmmax,roqimax,bvts1,       &
---
>              bvtr6,g6pbr,                             &
>              precr1,precr2,roqimax,bvts1,             &
39a48
>              n0g,avtg,bvtg,deng,lamdagmax,            & !RAS13.3 - set these in wsm6init
41c50,53
<              pidn0s,xlv1,pi,                          &
---
>              pidn0s,xlv1,pacrc,pi,                    &
>              bvtg1,bvtg2,bvtg3,bvtg4,g1pbg,           &
>              g3pbg,g4pbg,g5pbgo2,pvtg,pacrg,          &
>              precg1,precg2,pidn0g,                    &
46,48d57
< !
< ! Specifies code-inlining of fpvs function in WSM32D below. JM 20040507
< !
52,66c61,80
<   SUBROUTINE wsm3(th, q, qci, qrs                     &
<                    , w, den, pii, p, delz             &
<                    , delt,g, cpd, cpv, rd, rv, t0c    &
<                    , ep1, ep2, qmin                   &
<                    , XLS, XLV0, XLF0, den0, denr      &
<                    , cliq,cice,psat                   &
<                    , rain, rainncv                    &
<                    , snow, snowncv                    &
<                    , sr                               &
<                    , has_reqc, has_reqi, has_reqs     &  ! for radiation
<                    , re_cloud, re_ice,   re_snow      &  ! for radiation 
<                    , ids,ide, jds,jde, kds,kde        &
<                    , ims,ime, jms,jme, kms,kme        &
<                    , its,ite, jts,jte, kts,kte        &
<                                                       )
---
>   SUBROUTINE wsm6(th, q, qc, qr, qi, qs, qg                        &
>                  ,den, pii, p, delz                                &
>                  ,delt,g, cpd, cpv, rd, rv, t0c                    &
>                  ,ep1, ep2, qmin                                   &
>                  ,XLS, XLV0, XLF0, den0, denr                      &
>                  ,cliq,cice,psat                                   &
>                  ,rain, rainncv                                    &
>                  ,snow, snowncv                                    &
>                  ,sr                                               &
>                  ,refl_10cm, diagflag, do_radar_ref                &
>                  ,graupel, graupelncv                              &
>                  ,has_reqc, has_reqi, has_reqs                     &  ! for radiation
>                  ,re_cloud, re_ice,   re_snow                      &  ! for radiation   
>                  ,ids,ide, jds,jde, kds,kde                        &
>                  ,ims,ime, jms,jme, kms,kme                        &
>                  ,its,ite, jts,jte, kts,kte                        &
> #ifdef WRF_CHEM
>                  ,evapprod, rainprod                               &
> #endif
>                                                                    )
70,110c84,123
< !
<   INTEGER,      INTENT(IN   )    ::                ids,ide, jds,jde, kds,kde , &
<                                                    ims,ime, jms,jme, kms,kme , &
<                                                    its,ite, jts,jte, kts,kte
<   REAL, DIMENSION( ims:ime , kms:kme , jms:jme ),                              &
<         INTENT(INOUT) ::                                                       &
<                                                                           th,  &
<                                                                            q,  &
<                                                                           qci, &
<                                                                           qrs
<   REAL, DIMENSION( ims:ime , kms:kme , jms:jme ),                              &
<         INTENT(IN   ) ::                                                    w, &
<                                                                           den, &
<                                                                           pii, &
<                                                                             p, &
<                                                                          delz
<   REAL, INTENT(IN   ) ::                                                 delt, &
<                                                                             g, &
<                                                                            rd, &
<                                                                            rv, &
<                                                                           t0c, &
<                                                                          den0, &
<                                                                           cpd, &
<                                                                           cpv, &
<                                                                           ep1, &
<                                                                           ep2, &
<                                                                          qmin, &
<                                                                           XLS, &
<                                                                          XLV0, &
<                                                                          XLF0, &
<                                                                          cliq, &
<                                                                          cice, &
<                                                                          psat, &
<                                                                          denr
<   REAL, DIMENSION( ims:ime , jms:jme ),                                        &
<         INTENT(INOUT) ::                                                 rain, &
<                                                                       rainncv
<   REAL, DIMENSION( ims:ime , jms:jme ), OPTIONAL,                              &
<         INTENT(INOUT) ::                                                 snow, &
<                                                                       snowncv, &
<                                                                            sr
---
>   INTEGER,      INTENT(IN   )    ::   ids,ide, jds,jde, kds,kde , &
>                                       ims,ime, jms,jme, kms,kme , &
>                                       its,ite, jts,jte, kts,kte
>   REAL, DIMENSION( ims:ime , kms:kme , jms:jme ),                 &
>         INTENT(INOUT) ::                                          &
>                                                              th,  &
>                                                               q,  &
>                                                               qc, &
>                                                               qi, &
>                                                               qr, &
>                                                               qs, &
>                                                               qg
>   REAL, DIMENSION( ims:ime , kms:kme , jms:jme ),                 &
>         INTENT(IN   ) ::                                          &
>                                                              den, &
>                                                              pii, &
>                                                                p, &
>                                                             delz
>   REAL, INTENT(IN   ) ::                                    delt, &
>                                                                g, &
>                                                               rd, &
>                                                               rv, &
>                                                              t0c, &
>                                                             den0, &
>                                                              cpd, &
>                                                              cpv, &
>                                                              ep1, &
>                                                              ep2, &
>                                                             qmin, &
>                                                              XLS, &
>                                                             XLV0, &
>                                                             XLF0, &
>                                                             cliq, &
>                                                             cice, &
>                                                             psat, &
>                                                             denr
>   REAL, DIMENSION( ims:ime , jms:jme ),                           &
>         INTENT(INOUT) ::                                    rain, &
>                                                          rainncv, &
>                                                               sr
112,120c125,154
<   INTEGER, INTENT(IN)::                                                        &
<                                                                      has_reqc, &
<                                                                      has_reqi, &
<                                                                      has_reqs
<   REAL, DIMENSION(ims:ime, kms:kme, jms:jme),                                  &
<         INTENT(INOUT)::                                                        &
<                                                                      re_cloud, &
<                                                                        re_ice, &
<                                                                       re_snow
---
>   INTEGER, INTENT(IN)::                                           &
>                                                         has_reqc, &
>                                                         has_reqi, &
>                                                         has_reqs
>   REAL, DIMENSION(ims:ime, kms:kme, jms:jme),                     &
>         INTENT(INOUT)::                                           &
>                                                         re_cloud, &
>                                                           re_ice, &
>                                                          re_snow
> !+---+-----------------------------------------------------------------+
>   REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL,           &   ! GT
>         INTENT(INOUT) ::                               refl_10cm
> !+---+-----------------------------------------------------------------+
> 
>   REAL, DIMENSION( ims:ime , jms:jme ), OPTIONAL,                 &
>         INTENT(INOUT) ::                                    snow, &
>                                                          snowncv
>   REAL, DIMENSION( ims:ime , jms:jme ), OPTIONAL,                 &
>         INTENT(INOUT) ::                                 graupel, &
>                                                       graupelncv
> 
> #ifdef WRF_CHEM
>   REAL, DIMENSION( ims:ime , kms:kme, jms:jme ), INTENT(INOUT) :: &
>                                                       rainprod,   &
>                                                       evapprod
> ! local variable
>   REAL, DIMENSION( its:ite , kts:kte )                 ::         &
>                                                       rainprod2d, &
>                                                       evapprod2d
> #endif
123,124c157,160
<   REAL, DIMENSION( its:ite , kts:kte ) ::                                   t
<   INTEGER ::                                                            i,j,k
---
>   REAL, DIMENSION( its:ite , kts:kte ) ::   t
>   REAL, DIMENSION( its:ite , kts:kte, 2 ) ::   qci
>   REAL, DIMENSION( its:ite , kts:kte, 3 ) ::   qrs
>   INTEGER ::               i,j,k
125a162,166
> !+---+-----------------------------------------------------------------+
>       REAL, DIMENSION(kts:kte):: qv1d, t1d, p1d, qr1d, qs1d, qg1d, dBZ
>       LOGICAL, OPTIONAL, INTENT(IN) :: diagflag
>       INTEGER, OPTIONAL, INTENT(IN) :: do_radar_ref
> !+---+-----------------------------------------------------------------+
127d167
<   REAL, DIMENSION( kts:kte ) :: t1d
131d170
<   REAL, DIMENSION( kts:kte ) :: qs1d
134d172
< !-------------------------------------------------------------------
138a177,181
>             qci(i,k,1) = qc(i,k,j)
>             qci(i,k,2) = qi(i,k,j)
>             qrs(i,k,1) = qr(i,k,j)
>             qrs(i,k,2) = qs(i,k,j)
>             qrs(i,k,3) = qg(i,k,j)
141,155c184,204
<          CALL wsm32D(t, q(ims,kms,j), qci(ims,kms,j)                           &
<                     ,qrs(ims,kms,j),w(ims,kms,j), den(ims,kms,j)               &
<                     ,p(ims,kms,j), delz(ims,kms,j)                             &
<                     ,delt,g, cpd, cpv, rd, rv, t0c                             &
<                     ,ep1, ep2, qmin                                            &
<                     ,XLS, XLV0, XLF0, den0, denr                               &
<                     ,cliq,cice,psat                                            &
<                     ,j                                                         &
<                     ,rain(ims,j), rainncv(ims,j)                               &
<                     ,snow(ims,j),snowncv(ims,j)                                &
<                     ,sr(ims,j)                                                 &
<                     ,ids,ide, jds,jde, kds,kde                                 &
<                     ,ims,ime, jms,jme, kms,kme                                 &
<                     ,its,ite, jts,jte, kts,kte                                 &
<                                                                                )
---
>          !  Sending array starting locations of optional variables may cause
>          !  troubles, so we explicitly change the call.
>          CALL wsm62D(t, q(ims,kms,j), qci, qrs                     &
>                     ,den(ims,kms,j)                                &
>                     ,p(ims,kms,j), delz(ims,kms,j)                 &
>                     ,delt,g, cpd, cpv, rd, rv, t0c                 &
>                     ,ep1, ep2, qmin                                &
>                     ,XLS, XLV0, XLF0, den0, denr                   &
>                     ,cliq,cice,psat                                &
>                     ,j                                             &
>                     ,rain(ims,j),rainncv(ims,j)                    &
>                     ,sr(ims,j)                                     &
>                     ,ids,ide, jds,jde, kds,kde                     &
>                     ,ims,ime, jms,jme, kms,kme                     &
>                     ,its,ite, jts,jte, kts,kte                     &
>                     ,snow,snowncv                                  &
>                     ,graupel,graupelncv                            &
> #ifdef WRF_CHEM
>                    ,rainprod2d, evapprod2d                        &
> #endif
>                                                                    )
158a208,212
>             qc(i,k,j) = qci(i,k,1)
>             qi(i,k,j) = qci(i,k,2)
>             qr(i,k,j) = qrs(i,k,1)
>             qs(i,k,j) = qrs(i,k,2)
>             qg(i,k,j) = qrs(i,k,3)
161a216,236
> !+---+-----------------------------------------------------------------+
>          IF ( PRESENT (diagflag) ) THEN
>          if (diagflag .and. do_radar_ref == 1) then
>             DO I=its,ite
>                DO K=kts,kte
>                   t1d(k)=th(i,k,j)*pii(i,k,j)
>                   p1d(k)=p(i,k,j)
>                   qv1d(k)=q(i,k,j)
>                   qr1d(k)=qr(i,k,j)
>                   qs1d(k)=qs(i,k,j)
>                   qg1d(k)=qg(i,k,j)
>                ENDDO
>                call refl10cm_wsm6 (qv1d, qr1d, qs1d, qg1d,              &
>                        t1d, p1d, dBZ, kts, kte, i, j)
>                do k = kts, kte
>                   refl_10cm(i,k,j) = MAX(-35., dBZ(k))
>                enddo
>             ENDDO
>          endif
>          ENDIF
> 
171,179c246,248
<               if(t(i,k).ge.t0c) then
<                 qc1d(k) = qci(i,k,j)
<                 qi1d(k) = 0.0
<                 qs1d(k) = 0.0
<               else
<                 qc1d(k) = 0.0
<                 qi1d(k) = qci(i,k,j)
<                 qs1d(k) = qrs(i,k,j)
<               endif
---
>               qc1d(k) = qc(i,k,j)
>               qi1d(k) = qi(i,k,j)
>               qs1d(k) = qs(i,k,j)
181c250
<             call effectRad_wsm3(t1d, qc1d, qi1d, qs1d, den1d,           &
---
>             call effectRad_wsm6(t1d, qc1d, qi1d, qs1d, den1d,           &
188,189c257,258
<             enddo
<           enddo
---
>             enddo 
>           enddo   
191c260,268
< 
---
> !+---+-----------------------------------------------------------------+
> #ifdef WRF_CHEM
>         do i=its,ite
>           do k=kts,kte
>             rainprod(i,k,j) = rainprod2d(i,k)
>             evapprod(i,k,j) = evapprod2d(i,k)
>           enddo
>         enddo
> #endif
193c270
<   END SUBROUTINE wsm3
---
>   END SUBROUTINE wsm6
196,209c273,290
<   SUBROUTINE wsm32D(t, q                                                       &
<                    ,qci, qrs,w, den, p, delz                                   &
<                    ,delt,g, cpd, cpv, rd, rv, t0c                              &
<                    ,ep1, ep2, qmin                                             &
<                    ,XLS, XLV0, XLF0, den0, denr                                &
<                    ,cliq,cice,psat                                             &
<                    ,lat                                                        &
<                    ,rain, rainncv                                              &
<                    ,snow,snowncv                                               &
<                    ,sr                                                         &
<                    ,ids,ide, jds,jde, kds,kde                                  &
<                    ,ims,ime, jms,jme, kms,kme                                  &
<                    ,its,ite, jts,jte, kts,kte                                  &
<                                                                                )
---
>   SUBROUTINE wsm62D(t, q                                          &   
>                    ,qci, qrs, den, p, delz                        &
>                    ,delt,g, cpd, cpv, rd, rv, t0c                 &
>                    ,ep1, ep2, qmin                                &
>                    ,XLS, XLV0, XLF0, den0, denr                   &
>                    ,cliq,cice,psat                                &
>                    ,lat                                           &
>                    ,rain,rainncv                                  &
>                    ,sr                                            &
>                    ,ids,ide, jds,jde, kds,kde                     &
>                    ,ims,ime, jms,jme, kms,kme                     &
>                    ,its,ite, jts,jte, kts,kte                     &
>                    ,snow,snowncv                                  &
>                    ,graupel,graupelncv                            &
> #ifdef WRF_CHEM
>                    ,rainprod2d, evapprod2d                        &
> #endif
>                                                                   )
214c295
< !  This code is a 3-class simple ice microphyiscs scheme (WSM3) of the 
---
> !  This code is a 6-class GRAUPEL phase microphyiscs scheme (WSM6) of the 
220c301
< !  Production terms in the WSM6 scheme are described in Hong and Lim (2006).
---
> !  All production terms in the WSM6 scheme are described in Hong and Lim (2006).
223c304
< !  WSM3 cloud scheme
---
> !  WSM6 cloud scheme
225,227c306,307
< !  Developed by Song-You Hong (Yonsei Univ.), Jimy Dudhia (NCAR) 
< !             and Shu-Hua Chen (UC Davis) 
< !             Summer 2002
---
> !  Coded by Song-You Hong and Jeong-Ock Jade Lim (Yonsei Univ.)
> !           Summer 2003
230c310
< !             Summer 2003
---
> !           Summer 2004
234a315,318
> !        reflectivity computation from greg thompson, lim, jun 2011
> !        ==> only diagnostic, but with removal of too large drops
> !        add hail option from afwa, aug 2014
> !        ==> switch graupel or hail by changing no, den, fall vel.
236a321,322
> !        bug fix in melting terms, bae from kiaps, nov 2015
> !        ==> density of air is divided, which has not been
239d324
< !             Dudhia (D89, 1989) J. Atmos. Sci.
240a326,329
> !             Dudhia, Hong and Lim (DHL, 2008) J. Meteor. Soc. Japan
> !             Lin, Farley, Orville (LFO, 1983) J. Appl. Meteor.
> !             Rutledge, Hobbs (RH83, 1983) J. Atmos. Sci.
> !             Rutledge, Hobbs (RH84, 1984) J. Atmos. Sci.
243,284c332,387
<   INTEGER,      INTENT(IN   )    ::                 ids,ide, jds,jde, kds,kde, &
<                                                     ims,ime, jms,jme, kms,kme, &
<                                                     its,ite, jts,jte, kts,kte, &
<                                                     lat
<   REAL, DIMENSION( its:ite , kts:kte ),                                        &
<         INTENT(INOUT) ::                                                       &
<                                                                             t
<   REAL, DIMENSION( ims:ime , kms:kme ),                                        &
<         INTENT(INOUT) ::                                                       &
<                                                                             q, &
<                                                                           qci, &
<                                                                           qrs
<   REAL, DIMENSION( ims:ime , kms:kme ),                                        &
<         INTENT(IN   ) ::                                                    w, &
<                                                                           den, &
<                                                                             p, &
<                                                                          delz
<   REAL, INTENT(IN   ) ::                                                 delt, &
<                                                                             g, &
<                                                                           cpd, &
<                                                                           cpv, &
<                                                                           t0c, &
<                                                                          den0, &
<                                                                            rd, &
<                                                                            rv, &
<                                                                           ep1, &
<                                                                           ep2, &
<                                                                          qmin, &
<                                                                           XLS, &
<                                                                          XLV0, &
<                                                                          XLF0, &
<                                                                          cliq, &
<                                                                          cice, &
<                                                                          psat, &
<                                                                          denr
<   REAL, DIMENSION( ims:ime ),                                                  &
<         INTENT(INOUT) ::                                                 rain, &
<                                                                       rainncv
<   REAL, DIMENSION( ims:ime ),     OPTIONAL,                                    &
<         INTENT(INOUT) ::                                                 snow, &
<                                                                       snowncv, &
<                                                                            sr
---
>   INTEGER,      INTENT(IN   )    ::   ids,ide, jds,jde, kds,kde , &
>                                       ims,ime, jms,jme, kms,kme , &
>                                       its,ite, jts,jte, kts,kte,  &
>                                       lat
>   REAL, DIMENSION( its:ite , kts:kte ),                           &
>         INTENT(INOUT) ::                                          &
>                                                                t
>   REAL, DIMENSION( its:ite , kts:kte, 2 ),                        &
>         INTENT(INOUT) ::                                          &
>                                                              qci
>   REAL, DIMENSION( its:ite , kts:kte, 3 ),                        &
>         INTENT(INOUT) ::                                          &
>                                                              qrs
>   REAL, DIMENSION( ims:ime , kms:kme ),                           &
>         INTENT(INOUT) ::                                          &
>                                                                q
>   REAL, DIMENSION( ims:ime , kms:kme ),                           &
>         INTENT(IN   ) ::                                          &
>                                                              den, &
>                                                                p, &
>                                                             delz
>   REAL, INTENT(IN   ) ::                                    delt, &
>                                                                g, &
>                                                              cpd, &
>                                                              cpv, &
>                                                              t0c, &
>                                                             den0, &
>                                                               rd, &
>                                                               rv, &
>                                                              ep1, &
>                                                              ep2, &
>                                                             qmin, &
>                                                              XLS, &
>                                                             XLV0, &
>                                                             XLF0, &
>                                                             cliq, &
>                                                             cice, &
>                                                             psat, &
>                                                             denr
>   REAL, DIMENSION( ims:ime ),                                     &
>         INTENT(INOUT) ::                                    rain, &
>                                                          rainncv, &
>                                                               sr
>   REAL, DIMENSION( ims:ime, jms:jme ), OPTIONAL,                  &
>         INTENT(INOUT) ::                                    snow, &
>                                                          snowncv
>   REAL, DIMENSION( ims:ime, jms:jme ), OPTIONAL,                  &
>         INTENT(INOUT) ::                                 graupel, &
>                                                       graupelncv
> 
> #ifdef WRF_CHEM
>   REAL, DIMENSION( its:ite , kts:kte ), INTENT(INOUT)  ::         &
>                                                       rainprod2d, &
>                                                       evapprod2d
> #endif
> 
286,338c389,473
<   REAL, DIMENSION( its:ite , kts:kte ) ::                                      &
<                                                                            rh, &
<                                                                            qs, &
<                                                                        denfac, &
<                                                                        rslope, &
<                                                                       rslope2, &
<                                                                       rslope3, &
<                                                                       qrs_tmp, &
<                                                                       den_tmp, &
<                                                                      delz_tmp, &
<                                                                       rslopeb
<   REAL, DIMENSION( its:ite , kts:kte ) ::                                      &
<                                                                          pgen, &
<                                                                          pisd, &
<                                                                          paut, &
<                                                                          pacr, &
<                                                                          pres, &
<                                                                          pcon
<   REAL, DIMENSION( its:ite , kts:kte ) ::                                      &
<                                                                          fall, &
<                                                                          falk, &
<                                                                            xl, &
<                                                                           cpm, &
<                                                                         work1, &
<                                                                         work2, &
<                                                                           xni, &
<                                                                           qs0, &
<                                                                        denqci, &
<                                                                        denqrs, &
<                                                                        n0sfac, &
<                                                                         falkc, &
<                                                                        work1c, &
<                                                                        work2c, &
<                                                                         fallc
<   REAL, DIMENSION( its:ite ) ::                                         delqrs,&
<                                                                          delqi
<   REAL, DIMENSION(its:ite) ::                                        tstepsnow
<   INTEGER, DIMENSION( its:ite ) ::                                      kwork1,&
<                                                                         kwork2
<   INTEGER, DIMENSION( its:ite ) ::                                      mstep, &
<                                                                         numdt
<   LOGICAL, DIMENSION( its:ite ) :: flgcld
<   REAL  ::                                                                     &
<             cpmcal, xlcal, diffus,                                             &
<             viscos, xka, venfac, conden, diffac,                               &
<             x, y, z, a, b, c, d, e,                                            &
<             fallsum, fallsum_qsi, vt2i,vt2s,acrfac,                            &      
<             qdt, pvt, qik, delq, facq, qrsci, frzmlt,                          &
<             snomlt, hold, holdrs, facqci, supcol, coeres,                      &
<             supsat, dtcld, xmi, qciik, delqci, eacrs, satdt,                   &
<             qimax, diameter, xni0, roqi0, supice,holdc, holdci
<   INTEGER :: i, j, k, mstepmax,                                                &
<             iprt, latd, lond, loop, loops, ifsat, kk, n, idim, kdim
---
>   REAL, DIMENSION( its:ite , kts:kte , 3) ::                      &
>                                                               rh, &
>                                                               qs, &
>                                                           rslope, &
>                                                          rslope2, &
>                                                          rslope3, &
>                                                          rslopeb, &
>                                                          qrs_tmp, & 
>                                                             falk, &
>                                                             fall, &
>                                                            work1
>   REAL, DIMENSION( its:ite , kts:kte ) ::                         &
>                                                            fallc, &
>                                                            falkc, &
>                                                           work1c, &
>                                                           work2c, &
>                                                            workr, &
>                                                            worka
>   REAL, DIMENSION( its:ite , kts:kte ) ::                         &
>                                                          den_tmp, &
>                                                         delz_tmp
>   REAL, DIMENSION( its:ite , kts:kte ) ::                         &
>                                                            pigen, &
>                                                            pidep, &
>                                                            pcond, &
>                                                            prevp, &
>                                                            psevp, &
>                                                            pgevp, &
>                                                            psdep, &
>                                                            pgdep, &
>                                                            praut, &
>                                                            psaut, &
>                                                            pgaut, &
>                                                            piacr, &
>                                                            pracw, &
>                                                            praci, &
>                                                            pracs, &
>                                                            psacw, &
>                                                            psaci, &
>                                                            psacr, &
>                                                            pgacw, &
>                                                            pgaci, &
>                                                            pgacr, &
>                                                            pgacs, &
>                                                            paacw, &
>                                                            psmlt, &
>                                                            pgmlt, &
>                                                            pseml, &
>                                                            pgeml
>   REAL, DIMENSION( its:ite , kts:kte ) ::                         &
>                                                             qsum, &
>                                                               xl, &
>                                                              cpm, &
>                                                            work2, &
>                                                           denfac, &
>                                                              xni, &
>                                                          denqrs1, &
>                                                          denqrs2, &
>                                                          denqrs3, &
>                                                           denqci, & 
>                                                           n0sfac
>   REAL, DIMENSION( its:ite ) ::                          delqrs1, &
>                                                          delqrs2, &
>                                                          delqrs3, &
>                                                            delqi  
>   REAL, DIMENSION( its:ite ) ::                        tstepsnow, &
>                                                       tstepgraup
>   INTEGER, DIMENSION( its:ite ) ::                         mstep, &
>                                                            numdt
>   LOGICAL, DIMENSION( its:ite ) ::                        flgcld
>   REAL  ::                                                        &
>             cpmcal, xlcal, diffus,                                &
>             viscos, xka, venfac, conden, diffac,                  &
>             x, y, z, a, b, c, d, e,                               &
>             qdt, holdrr, holdrs, holdrg, supcol, supcolt, pvt,    &
>             coeres, supsat, dtcld, xmi, eacrs, satdt,             &
>             qimax, diameter, xni0, roqi0,                         &
>             fallsum, fallsum_qsi, fallsum_qg,                     &
>             vt2i,vt2r,vt2s,vt2g,acrfac,egs,egi,                   &
>             xlwork2, factor, source, value,                       &
>             xlf, pfrzdtc, pfrzdtr, supice, alpha2, delta2, delta3  
>   REAL  :: vt2ave
>   REAL  :: holdc, holdci
>   INTEGER :: i, j, k, mstepmax,                                   &
>             iprt, latd, lond, loop, loops, ifsat, n, idim, kdim
342c477,478
<   REAL, DIMENSION( its:ite )    :: tvec1
---
>   REAL, DIMENSION( its:ite ) ::                             tvec1
>   REAL                       ::                              temp
361a498
> !
370,371c507,511
<           qci(i,k) = max(qci(i,k),0.0)
<           qrs(i,k) = max(qrs(i,k),0.0)
---
>           qci(i,k,1) = max(qci(i,k,1),0.0)
>           qrs(i,k,1) = max(qrs(i,k,1),0.0)
>           qci(i,k,2) = max(qci(i,k,2),0.0)
>           qrs(i,k,2) = max(qrs(i,k,2),0.0)
>           qrs(i,k,3) = max(qrs(i,k,3),0.0)
394c534
< !    initialize the surface rain, snow
---
> !    initialize the surface rain, snow, graupel
398c538,539
<         if(PRESENT (snowncv) .AND. PRESENT (snow)) snowncv(i) = 0.
---
>         if(PRESENT (snowncv) .AND. PRESENT (snow)) snowncv(i,lat) = 0.
>         if(PRESENT (graupelncv) .AND. PRESENT (graupel)) graupelncv(i,lat) = 0.
400c541
< ! new local array to catch step snow
---
> ! new local array to catch step snow and graupel
401a543
>         tstepgraup(i) = 0.
416a559
>         mstep(i) = 1
419a563,567
> !     do k = kts, kte
> !       do i = its, ite
> !         denfac(i,k) = sqrt(den0/den(i,k))
> !       enddo
> !     enddo
429,430c577,580
< !         qs(i,k) = fpvs(t(i,k),1,rd,rv,cpv,cliq,cice,xlv0,xls,psat,t0c)
< !         qs0(i,k) = fpvs(t(i,k),0,rd,rv,cpv,cliq,cice,xlv0,xls,psat,t0c)
---
> !         qs(i,k,1) = fpvs(t(i,k),0,rd,rv,cpv,cliq,cice,xlv0,xls,psat,t0c)
> !         qs(i,k,2) = fpvs(t(i,k),1,rd,rv,cpv,cliq,cice,xlv0,xls,psat,t0c)
>       hsub = xls
>       hvap = xlv0
432,433d581
<       hvap=xlv0
<       hsub=xls
443a592,597
>           qs(i,k,1)=psat*exp(log(tr)*(xa))*exp(xb*(1.-tr))
>           qs(i,k,1) = min(qs(i,k,1),0.99*p(i,k))
>           qs(i,k,1) = ep2 * qs(i,k,1) / (p(i,k) - qs(i,k,1))
>           qs(i,k,1) = max(qs(i,k,1),qmin)
>           rh(i,k,1) = max(q(i,k) / qs(i,k,1),qmin)
>           tr=ttp/t(i,k)
445c599
<             qs(i,k) =psat*(exp(log(tr)*(xai)))*exp(xbi*(1.-tr))
---
>             qs(i,k,2)=psat*exp(log(tr)*(xai))*exp(xbi*(1.-tr))
447c601
<             qs(i,k) =psat*(exp(log(tr)*(xa)))*exp(xb*(1.-tr))
---
>             qs(i,k,2)=psat*exp(log(tr)*(xa))*exp(xb*(1.-tr))
449,454c603,606
<           qs0(i,k)  =psat*(exp(log(tr)*(xa)))*exp(xb*(1.-tr))
<           qs0(i,k) = (qs0(i,k)-qs(i,k))/qs(i,k)
<           qs(i,k) = min(qs(i,k),0.99*p(i,k))
<           qs(i,k) = ep2 * qs(i,k) / (p(i,k) - qs(i,k))
<           qs(i,k) = max(qs(i,k),qmin)
<           rh(i,k) = max(q(i,k) / qs(i,k),qmin)
---
>           qs(i,k,2) = min(qs(i,k,2),0.99*p(i,k))
>           qs(i,k,2) = ep2 * qs(i,k,2) / (p(i,k) - qs(i,k,2))
>           qs(i,k,2) = max(qs(i,k,2),qmin)
>           rh(i,k,2) = max(q(i,k) / qs(i,k,2),qmin)
464,471c616,648
<           pres(i,k) = 0.
<           paut(i,k) = 0.
<           pacr(i,k) = 0.
<           pgen(i,k) = 0.
<           pisd(i,k) = 0.
<           pcon(i,k) = 0.
<           fall(i,k) = 0.
<           falk(i,k) = 0.
---
>           prevp(i,k) = 0.
>           psdep(i,k) = 0.
>           pgdep(i,k) = 0.
>           praut(i,k) = 0.
>           psaut(i,k) = 0.
>           pgaut(i,k) = 0.
>           pracw(i,k) = 0.
>           praci(i,k) = 0.
>           piacr(i,k) = 0.
>           psaci(i,k) = 0.
>           psacw(i,k) = 0.
>           pracs(i,k) = 0.
>           psacr(i,k) = 0.
>           pgacw(i,k) = 0.
>           paacw(i,k) = 0.
>           pgaci(i,k) = 0.
>           pgacr(i,k) = 0.
>           pgacs(i,k) = 0.
>           pigen(i,k) = 0.
>           pidep(i,k) = 0.
>           pcond(i,k) = 0.
>           psmlt(i,k) = 0.
>           pgmlt(i,k) = 0.
>           pseml(i,k) = 0.
>           pgeml(i,k) = 0.
>           psevp(i,k) = 0.
>           pgevp(i,k) = 0.
>           falk(i,k,1) = 0.
>           falk(i,k,2) = 0.
>           falk(i,k,3) = 0.
>           fall(i,k,1) = 0.
>           fall(i,k,2) = 0.
>           fall(i,k,3) = 0.
482,483c659,661
<           xni(i,k) = min(max(5.38e7                                            &
<                     *exp(log((den(i,k)*max(qci(i,k),qmin)))*(0.75)),1.e3),1.e6)
---
>           temp = (den(i,k)*max(qci(i,k,2),qmin))
>           temp = sqrt(sqrt(temp*temp*temp))
>           xni(i,k) = min(max(5.38e7*temp,1.e3),1.e6)
490c668
< !---------------------------------------------------------------
---
> !----------------------------------------------------------------
493c671,673
<           qrs_tmp(i,k) = qrs(i,k)
---
>           qrs_tmp(i,k,1) = qrs(i,k,1)
>           qrs_tmp(i,k,2) = qrs(i,k,2)
>           qrs_tmp(i,k,3) = qrs(i,k,3)
496,500c676,677
<       call slope_wsm3(qrs_tmp,den_tmp,denfac,t,rslope,rslopeb,rslope2,rslope3, &
<                       work1,its,ite,kts,kte)
< !
< !
< !  forward semi-laglangian scheme (JH), PCM (piecewise constant),  (linear)
---
>       call slope_wsm6(qrs_tmp,den_tmp,denfac,t,rslope,rslopeb,rslope2,rslope3, & 
>                      work1,its,ite,kts,kte)
504c681,706
<           denqrs(i,k) = den(i,k)*qrs(i,k)
---
>           workr(i,k) = work1(i,k,1)
>           qsum(i,k) = max( (qrs(i,k,2)+qrs(i,k,3)), 1.E-15)
>           IF ( qsum(i,k) .gt. 1.e-15 ) THEN
>             worka(i,k) = (work1(i,k,2)*qrs(i,k,2) + work1(i,k,3)*qrs(i,k,3)) &
>                       /qsum(i,k)
>           ELSE
>             worka(i,k) = 0.
>           ENDIF
>           denqrs1(i,k) = den(i,k)*qrs(i,k,1)
>           denqrs2(i,k) = den(i,k)*qrs(i,k,2)
>           denqrs3(i,k) = den(i,k)*qrs(i,k,3)
>           if(qrs(i,k,1).le.0.0) workr(i,k) = 0.0
>         enddo
>       enddo
>       call nislfv_rain_plm(idim,kdim,den_tmp,denfac,t,delz_tmp,workr,denqrs1,  &
>                            delqrs1,dtcld,1,1)
>       call nislfv_rain_plm6(idim,kdim,den_tmp,denfac,t,delz_tmp,worka,         & 
>                            denqrs2,denqrs3,delqrs2,delqrs3,dtcld,1,1)
>       do k = kts, kte
>         do i = its, ite
>           qrs(i,k,1) = max(denqrs1(i,k)/den(i,k),0.)
>           qrs(i,k,2) = max(denqrs2(i,k)/den(i,k),0.)
>           qrs(i,k,3) = max(denqrs3(i,k)/den(i,k),0.)
>           fall(i,k,1) = denqrs1(i,k)*workr(i,k)/delz(i,k)
>           fall(i,k,2) = denqrs2(i,k)*worka(i,k)/delz(i,k)
>           fall(i,k,3) = denqrs3(i,k)*worka(i,k)/delz(i,k)
507,508c709,713
<       call nislfv_rain_plm(idim,kdim,den_tmp,denfac,t,delz_tmp,work1,denqrs,   &
<                            delqrs,dtcld,1,1)
---
>       do i = its, ite
>         fall(i,1,1) = delqrs1(i)/delz(i,1)/dtcld
>         fall(i,1,2) = delqrs2(i)/delz(i,1)/dtcld
>         fall(i,1,3) = delqrs3(i)/delz(i,1)/dtcld
>       enddo
511,512c716,718
<           qrs(i,k) = max(denqrs(i,k)/den(i,k),0.)
<           fall(i,k) = denqrs(i,k)*work1(i,k)/delz(i,k)
---
>           qrs_tmp(i,k,1) = qrs(i,k,1)
>           qrs_tmp(i,k,2) = qrs(i,k,2)
>           qrs_tmp(i,k,3) = qrs(i,k,3)
515,516c721,762
<       do i = its, ite
<         fall(i,1) = delqrs(i)/delz(i,1)/dtcld
---
>       call slope_wsm6(qrs_tmp,den_tmp,denfac,t,rslope,rslopeb,rslope2,rslope3, &
>                      work1,its,ite,kts,kte)
> !
>       do k = kte, kts, -1 
>         do i = its, ite
>           supcol = t0c-t(i,k)
>           n0sfac(i,k) = max(min(exp(alpha*supcol),n0smax/n0s),1.)
>           if(t(i,k).gt.t0c) then
> !---------------------------------------------------------------
> ! psmlt: melting of snow [HL A33] [RH83 A25]
> !       (T>T0: S->R)
> !---------------------------------------------------------------
>             xlf = xlf0
>             work2(i,k) = venfac(p(i,k),t(i,k),den(i,k))
>             if(qrs(i,k,2).gt.0.) then
>               coeres = rslope2(i,k,2)*sqrt(rslope(i,k,2)*rslopeb(i,k,2))
>               psmlt(i,k) = xka(t(i,k),den(i,k))/xlf*(t0c-t(i,k))*pi/2.       &
>                          *n0sfac(i,k)*(precs1*rslope2(i,k,2)                 &
>                          +precs2*work2(i,k)*coeres)/den(i,k)
>               psmlt(i,k) = min(max(psmlt(i,k)*dtcld/mstep(i),                &
>                           -qrs(i,k,2)/mstep(i)),0.)
>               qrs(i,k,2) = qrs(i,k,2) + psmlt(i,k)
>               qrs(i,k,1) = qrs(i,k,1) - psmlt(i,k)
>               t(i,k) = t(i,k) + xlf/cpm(i,k)*psmlt(i,k)
>             endif
> !---------------------------------------------------------------
> ! pgmlt: melting of graupel [HL A23]  [LFO 47]
> !       (T>T0: G->R)
> !---------------------------------------------------------------
>             if(qrs(i,k,3).gt.0.) then
>               coeres = rslope2(i,k,3)*sqrt(rslope(i,k,3)*rslopeb(i,k,3))
>               pgmlt(i,k) = xka(t(i,k),den(i,k))/xlf                          &
>                          *(t0c-t(i,k))*(precg1*rslope2(i,k,3)                &
>                          +precg2*work2(i,k)*coeres)/den(i,k)
>               pgmlt(i,k) = min(max(pgmlt(i,k)*dtcld/mstep(i),                &
>                           -qrs(i,k,3)/mstep(i)),0.)                          
>               qrs(i,k,3) = qrs(i,k,3) + pgmlt(i,k)
>               qrs(i,k,1) = qrs(i,k,1) - pgmlt(i,k)
>               t(i,k) = t(i,k) + xlf/cpm(i,k)*pgmlt(i,k)
>             endif
>           endif
>         enddo
523,527c769
<           if(t(i,k).lt.t0c.and.qci(i,k).gt.0.) then
<             xmi = den(i,k)*qci(i,k)/xni(i,k)
<             diameter  = max(dicon * sqrt(xmi), 1.e-25)
<             work1c(i,k) = 1.49e4*exp(log(diameter)*(1.31))
<           else
---
>           if(qci(i,k,2).le.0.) then
528a771,774
>           else
>             xmi = den(i,k)*qci(i,k,2)/xni(i,k)
>             diameter  = max(min(dicon * sqrt(xmi),dimax), 1.e-25)
>             work1c(i,k) = 1.49e4*exp(log(diameter)*(1.31))
537c783
<           denqci(i,k) = den(i,k)*qci(i,k)
---
>           denqci(i,k) = den(i,k)*qci(i,k,2)
544c790
<           qci(i,k) = max(denqci(i,k)/den(i,k),0.)
---
>           qci(i,k,2) = max(denqci(i,k)/den(i,k),0.)
552,597d797
< !     compute the freezing/melting term. [D89 B16-B17]
< !     freezing occurs one layer above the melting level
< !
<       do i = its, ite
<         mstep(i) = 0
<       enddo
<       do k = kts, kte
< !
<         do i = its, ite
<           if(t(i,k).ge.t0c) then
<             mstep(i) = k
<           endif
<         enddo
<       enddo
< !
<       do i = its, ite
<         kwork2(i) = mstep(i)
<         kwork1(i) = mstep(i)
<         if(mstep(i).ne.0) then
<           if (w(i,mstep(i)).gt.0.) then
<             kwork1(i) = mstep(i) + 1
<           endif
<         endif
<       enddo
< !
<       do i = its, ite
<         k  = kwork1(i)
<         kk = kwork2(i)
<         if(k*kk.ge.1) then
<           qrsci = qrs(i,k) + qci(i,k)
<           if(qrsci.gt.0..or.fall(i,kk).gt.0.) then
<             frzmlt = min(max(-w(i,k)*qrsci/delz(i,k),-qrsci/dtcld),            &
<                     qrsci/dtcld)
<             snomlt = min(max(fall(i,kk)/den(i,kk),-qrs(i,k)/dtcld),            &
<                     qrs(i,k)/dtcld)
<             if(k.eq.kk) then
<               t(i,k) = t(i,k) - xlf0/cpm(i,k)*(frzmlt+snomlt)*dtcld
<             else
<               t(i,k) = t(i,k) - xlf0/cpm(i,k)*frzmlt*dtcld
<               t(i,kk) = t(i,kk) - xlf0/cpm(i,kk)*snomlt*dtcld
<             endif
<           endif
<         endif
<       enddo
< !
< !----------------------------------------------------------------
601,606c801,803
<         fallsum = fall(i,1)
<         fallsum_qsi = 0.
<         if((t0c-t(i,1)).gt.0) then
<         fallsum = fallsum+fallc(i,1)
<         fallsum_qsi = fall(i,1)+fallc(i,1)
<         endif
---
>         fallsum = fall(i,kts,1)+fall(i,kts,2)+fall(i,kts,3)+fallc(i,kts)
>         fallsum_qsi = fall(i,kts,2)+fallc(i,kts)
>         fallsum_qg = fall(i,kts,3)
608,609c805,806
<           rainncv(i) = fallsum*delz(i,1)/denr*dtcld*1000. + rainncv(i)
<           rain(i) = fallsum*delz(i,1)/denr*dtcld*1000. + rain(i)
---
>           rainncv(i) = fallsum*delz(i,kts)/denr*dtcld*1000. + rainncv(i)
>           rain(i) = fallsum*delz(i,kts)/denr*dtcld*1000. + rain(i)
615,616c812,814
<           snowncv(i) = fallsum_qsi*delz(i,kts)/denr*dtcld*1000. + snowncv(i)
<           snow(i) = fallsum_qsi*delz(i,kts)/denr*dtcld*1000. + snow(i)
---
>           snowncv(i,lat) = fallsum_qsi*delz(i,kts)/denr*dtcld*1000.            & 
>                            +snowncv(i,lat)
>           snow(i,lat) = fallsum_qsi*delz(i,kts)/denr*dtcld*1000. + snow(i,lat)
619,620c817,827
<         IF ( PRESENT (snowncv) ) THEN
<           if(fallsum.gt.0.) sr(i) = snowncv(i)/(rainncv(i)+1.e-12)
---
>         if(fallsum_qg.gt.0.) then
>           tstepgraup(i)  = fallsum_qg*delz(i,kts)/denr*dtcld*1000.            &
>                            +tstepgraup(i)
>         IF ( PRESENT (graupelncv) .AND. PRESENT (graupel)) THEN
>           graupelncv(i,lat) = fallsum_qg*delz(i,kts)/denr*dtcld*1000.          &   
>                               + graupelncv(i,lat)
>           graupel(i,lat) = fallsum_qg*delz(i,kts)/denr*dtcld*1000. + graupel(i,lat)
>         ENDIF
>         endif
>         IF ( PRESENT (snowncv)) THEN
>           if(fallsum.gt.0.)sr(i)=(snowncv(i,lat) + graupelncv(i,lat))/(rainncv(i)+1.e-12)
622c829
<           if(fallsum.gt.0.) sr(i) = tstepsnow(i)/(rainncv(i)+1.e-12)
---
>           if(fallsum.gt.0.)sr(i)=(tstepsnow(i) + tstepgraup(i))/(rainncv(i)+1.e-12)
625a833,891
> !---------------------------------------------------------------
> ! pimlt: instantaneous melting of cloud ice [HL A47] [RH83 A28]
> !       (T>T0: I->C)
> !---------------------------------------------------------------
>       do k = kts, kte
>         do i = its, ite
>           supcol = t0c-t(i,k)
>           xlf = xls-xl(i,k)
>           if(supcol.lt.0.) xlf = xlf0
>           if(supcol.lt.0.and.qci(i,k,2).gt.0.) then
>             qci(i,k,1) = qci(i,k,1) + qci(i,k,2)
>             t(i,k) = t(i,k) - xlf/cpm(i,k)*qci(i,k,2)
>             qci(i,k,2) = 0.
>           endif
> !---------------------------------------------------------------
> ! pihmf: homogeneous freezing of cloud water below -40c [HL A45]
> !        (T<-40C: C->I)
> !---------------------------------------------------------------
>           if(supcol.gt.40..and.qci(i,k,1).gt.0.) then
>             qci(i,k,2) = qci(i,k,2) + qci(i,k,1)
>             t(i,k) = t(i,k) + xlf/cpm(i,k)*qci(i,k,1)
>             qci(i,k,1) = 0.
>           endif
> !---------------------------------------------------------------
> ! pihtf: heterogeneous freezing of cloud water [HL A44]
> !        (T0>T>-40C: C->I)
> !---------------------------------------------------------------
>           if(supcol.gt.0..and.qci(i,k,1).gt.qmin) then
> !           pfrzdtc = min(pfrz1*(exp(pfrz2*supcol)-1.)                         &
> !              *den(i,k)/denr/xncr*qci(i,k,1)**2*dtcld,qci(i,k,1))
>             supcolt=min(supcol,50.)
>             pfrzdtc = min(pfrz1*(exp(pfrz2*supcolt)-1.)                        &
>             *den(i,k)/denr/xncr*qci(i,k,1)*qci(i,k,1)*dtcld,qci(i,k,1))
>             qci(i,k,2) = qci(i,k,2) + pfrzdtc
>             t(i,k) = t(i,k) + xlf/cpm(i,k)*pfrzdtc
>             qci(i,k,1) = qci(i,k,1)-pfrzdtc
>           endif
> !---------------------------------------------------------------
> ! pgfrz: freezing of rain water [HL A20] [LFO 45]
> !        (T<T0, R->G)
> !---------------------------------------------------------------
>           if(supcol.gt.0..and.qrs(i,k,1).gt.0.) then
> !           pfrzdtr = min(20.*pi**2*pfrz1*n0r*denr/den(i,k)                    &
> !                 *(exp(pfrz2*supcol)-1.)*rslope3(i,k,1)**2                    &
> !                 *rslope(i,k,1)*dtcld,qrs(i,k,1))
>             temp = rslope3(i,k,1)
>             temp = temp*temp*rslope(i,k,1)
>             supcolt=min(supcol,50.)
>             pfrzdtr = min(20.*(pi*pi)*pfrz1*n0r*denr/den(i,k)                  &
>                   *(exp(pfrz2*supcolt)-1.)*temp*dtcld,                         &
>                   qrs(i,k,1))
>             qrs(i,k,3) = qrs(i,k,3) + pfrzdtr
>             t(i,k) = t(i,k) + xlf/cpm(i,k)*pfrzdtr
>             qrs(i,k,1) = qrs(i,k,1)-pfrzdtr
>           endif
>         enddo
>       enddo
> !
> !
627c893
< !     update the slope parameters for microphysics computation 
---
> !     update the slope parameters for microphysics computation
631c897,899
<           qrs_tmp(i,k) = qrs(i,k)
---
>           qrs_tmp(i,k,1) = qrs(i,k,1)
>           qrs_tmp(i,k,2) = qrs(i,k,2)
>           qrs_tmp(i,k,3) = qrs(i,k,3)
634,637c902,905
<       call slope_wsm3(qrs_tmp,den_tmp,denfac,t,rslope,rslopeb,rslope2,rslope3, &
<                       work1,its,ite,kts,kte)
< !
< !     work1: the thermodynamic term in the denominator associated with
---
>       call slope_wsm6(qrs_tmp,den_tmp,denfac,t,rslope,rslopeb,rslope2,rslope3, &
>                      work1,its,ite,kts,kte)
> !------------------------------------------------------------------
> !     work1:  the thermodynamic term in the denominator associated with
638a907
> !             (ry88, y93, h85)
643,647c912,913
<           if(t(i,k).ge.t0c) then
<             work1(i,k) = diffac(xl(i,k),p(i,k),t(i,k),den(i,k),qs(i,k))
<           else
<             work1(i,k) = diffac(xls,p(i,k),t(i,k),den(i,k),qs(i,k))
<           endif
---
>           work1(i,k,1) = diffac(xl(i,k),p(i,k),t(i,k),den(i,k),qs(i,k,1))
>           work1(i,k,2) = diffac(xls,p(i,k),t(i,k),den(i,k),qs(i,k,2))
652,657d917
<       do k = kts, kte
<         do i = its, ite
<           supsat = max(q(i,k),qmin)-qs(i,k)
<           satdt = supsat/dtcld
<           if(t(i,k).ge.t0c) then
< !
664a925,929
> !
>       do k = kts, kte
>         do i = its, ite
>           supsat = max(q(i,k),qmin)-qs(i,k,1)
>           satdt = supsat/dtcld
669,673c934,937
<             if(qci(i,k).gt.qc0) then
< !             paut(i,k) = qck1*qci(i,k)**(7./3.)
<               paut(i,k) = qck1*exp(log(qci(i,k))*((7./3.)))
<               paut(i,k) = min(paut(i,k),qci(i,k)/dtcld)
<             endif
---
>           if(qci(i,k,1).gt.qc0) then
>             praut(i,k) = qck1*qci(i,k,1)**(7./3.)
>             praut(i,k) = min(praut(i,k),qci(i,k,1)/dtcld)
>           endif
675c939
< ! pracw: accretion of cloud water by rain [HL A40] [D89 B15]
---
> ! pracw: accretion of cloud water by rain [HL A40] [LFO 51]
678,681c942,945
<             if(qrs(i,k).gt.qcrmin.and.qci(i,k).gt.qmin) then
<                 pacr(i,k) = min(pacrr*rslope3(i,k)*rslopeb(i,k)                &
<                      *qci(i,k)*denfac(i,k),qci(i,k)/dtcld)
<             endif
---
>           if(qrs(i,k,1).gt.qcrmin.and.qci(i,k,1).gt.qmin) then
>             pracw(i,k) = min(pacrr*rslope3(i,k,1)*rslopeb(i,k,1)               &
>                         *qci(i,k,1)*denfac(i,k),qci(i,k,1)/dtcld)
>           endif
686,695c950,958
<             if(qrs(i,k).gt.0.) then
<                 coeres = rslope2(i,k)*sqrt(rslope(i,k)*rslopeb(i,k))
<                 pres(i,k) = (rh(i,k)-1.)*(precr1*rslope2(i,k)                  &
<                          +precr2*work2(i,k)*coeres)/work1(i,k)
<               if(pres(i,k).lt.0.) then
<                 pres(i,k) = max(pres(i,k),-qrs(i,k)/dtcld)
<                 pres(i,k) = max(pres(i,k),satdt/2)
<               else
<                 pres(i,k) = min(pres(i,k),satdt/2)
<               endif
---
>           if(qrs(i,k,1).gt.0.) then
>             coeres = rslope2(i,k,1)*sqrt(rslope(i,k,1)*rslopeb(i,k,1))
>             prevp(i,k) = (rh(i,k,1)-1.)*(precr1*rslope2(i,k,1)                 &
>                          +precr2*work2(i,k)*coeres)/work1(i,k,1)
>             if(prevp(i,k).lt.0.) then
>               prevp(i,k) = max(prevp(i,k),-qrs(i,k,1)/dtcld)
>               prevp(i,k) = max(prevp(i,k),satdt/2)
>             else
>               prevp(i,k) = min(prevp(i,k),satdt/2)
697c960,962
<           else
---
>           endif
>         enddo
>       enddo
704c969
< ! - the processes same as in RH83 and LFO behave
---
> ! - the processes same as in RH83 and RH84  and LFO behave
712,714c977,983
<             supcol = t0c-t(i,k)
<             n0sfac(i,k) = max(min(exp(alpha*supcol),n0smax/n0s),1.)
<             ifsat = 0
---
>       do k = kts, kte
>         do i = its, ite
>           supcol = t0c-t(i,k)
>           n0sfac(i,k) = max(min(exp(alpha*supcol),n0smax/n0s),1.)
>           supsat = max(q(i,k),qmin)-qs(i,k,2)
>           satdt = supsat/dtcld
>           ifsat = 0
718,725c987,1007
<             xni(i,k) = min(max(5.38e7                                          &
<                     *exp(log((den(i,k)*max(qci(i,k),qmin)))*(0.75)),1.e3),1.e6)
<             eacrs = exp(0.07*(-supcol))
<             if(qrs(i,k).gt.qcrmin.and.qci(i,k).gt.qmin) then
<               xmi = den(i,k)*qci(i,k)/xni(i,k)
<               diameter  = min(dicon * sqrt(xmi),dimax)
<               vt2i = 1.49e4*diameter**1.31
<               vt2s = pvts*rslopeb(i,k)*denfac(i,k)
---
> !         xni(i,k) = min(max(5.38e7*(den(i,k)                                  &
> !                      *max(qci(i,k,2),qmin))**0.75,1.e3),1.e6)
>           temp = (den(i,k)*max(qci(i,k,2),qmin))
>           temp = sqrt(sqrt(temp*temp*temp))
>           xni(i,k) = min(max(5.38e7*temp,1.e3),1.e6)
>           eacrs = exp(0.07*(-supcol))
> !
>           xmi = den(i,k)*qci(i,k,2)/xni(i,k)
>           diameter  = min(dicon * sqrt(xmi),dimax)
>           vt2i = 1.49e4*diameter**1.31
>           vt2r=pvtr*rslopeb(i,k,1)*denfac(i,k)
>           vt2s=pvts*rslopeb(i,k,2)*denfac(i,k)
>           vt2g=pvtg*rslopeb(i,k,3)*denfac(i,k)
>           qsum(i,k) = max( (qrs(i,k,2)+qrs(i,k,3)), 1.E-15)
>           if(qsum(i,k) .gt. 1.e-15) then
>           vt2ave=(vt2s*qrs(i,k,2)+vt2g*qrs(i,k,3))/(qsum(i,k))
>           else
>           vt2ave=0.
>           endif
>           if(supcol.gt.0.and.qci(i,k,2).gt.qmin) then
>             if(qrs(i,k,1).gt.qcrmin) then
730,733c1012,1038
<               acrfac = 2.*rslope3(i,k)+2.*diameter*rslope2(i,k)                &
<                       +diameter**2*rslope(i,k)
<               pacr(i,k) = min(pi*qci(i,k)*eacrs*n0s*n0sfac(i,k)                &
<                        *abs(vt2s-vt2i)*acrfac/4.,qci(i,k)/dtcld)
---
>               acrfac = 2.*rslope3(i,k,1)+2.*diameter*rslope2(i,k,1)            &
>                       +diameter**2*rslope(i,k,1)
>               praci(i,k) = pi*qci(i,k,2)*n0r*abs(vt2r-vt2i)*acrfac/4.
>               ! reduce collection efficiency (suggested by B. Wilt)
>               praci(i,k) = praci(i,k)*min(max(0.0,qrs(i,k,1)/qci(i,k,2)),1.)**2
>               praci(i,k) = min(praci(i,k),qci(i,k,2)/dtcld)
> !-------------------------------------------------------------
> ! piacr: Accretion of rain by cloud ice [HL A19] [LFO 26]
> !        (T<T0: R->S or R->G)
> !-------------------------------------------------------------
>               piacr(i,k) = pi**2*avtr*n0r*denr*xni(i,k)*denfac(i,k)            &
>                           *g6pbr*rslope3(i,k,1)*rslope3(i,k,1)                 &
>                           *rslopeb(i,k,1)/24./den(i,k)
>               ! reduce collection efficiency (suggested by B. Wilt)
>               piacr(i,k) = piacr(i,k)*min(max(0.0,qci(i,k,2)/qrs(i,k,1)),1.)**2
>               piacr(i,k) = min(piacr(i,k),qrs(i,k,1)/dtcld)
>             endif
> !-------------------------------------------------------------
> ! psaci: Accretion of cloud ice by snow [HDC 10]
> !        (T<T0: I->S)
> !-------------------------------------------------------------
>             if(qrs(i,k,2).gt.qcrmin) then
>               acrfac = 2.*rslope3(i,k,2)+2.*diameter*rslope2(i,k,2)            &
>                       +diameter**2*rslope(i,k,2)
>               psaci(i,k) = pi*qci(i,k,2)*eacrs*n0s*n0sfac(i,k)                 &
>                           *abs(vt2ave-vt2i)*acrfac/4.
>               psaci(i,k) = min(psaci(i,k),qci(i,k,2)/dtcld)
735a1041,1149
> ! pgaci: Accretion of cloud ice by graupel [HL A17] [LFO 41]
> !        (T<T0: I->G)
> !-------------------------------------------------------------
>             if(qrs(i,k,3).gt.qcrmin) then
>               egi = exp(0.07*(-supcol))
>               acrfac = 2.*rslope3(i,k,3)+2.*diameter*rslope2(i,k,3)            &
>                       +diameter**2*rslope(i,k,3)
>               pgaci(i,k) = pi*egi*qci(i,k,2)*n0g*abs(vt2ave-vt2i)*acrfac/4.
>               pgaci(i,k) = min(pgaci(i,k),qci(i,k,2)/dtcld)
>             endif
>           endif
> !-------------------------------------------------------------
> ! psacw: Accretion of cloud water by snow  [HL A7] [LFO 24]
> !        (T<T0: C->S, and T>=T0: C->R)
> !-------------------------------------------------------------
>           if(qrs(i,k,2).gt.qcrmin.and.qci(i,k,1).gt.qmin) then
>             psacw(i,k) = min(pacrc*n0sfac(i,k)*rslope3(i,k,2)*rslopeb(i,k,2)   &    
>               ! reduce collection efficiency (suggested by B. Wilt)
>                         *min(max(0.0,qrs(i,k,2)/qci(i,k,1)),1.)**2             &
>                         *qci(i,k,1)*denfac(i,k),qci(i,k,1)/dtcld)
>           endif
> !-------------------------------------------------------------
> ! pgacw: Accretion of cloud water by graupel [HL A6] [LFO 40]
> !        (T<T0: C->G, and T>=T0: C->R)
> !-------------------------------------------------------------
>           if(qrs(i,k,3).gt.qcrmin.and.qci(i,k,1).gt.qmin) then
>             pgacw(i,k) = min(pacrg*rslope3(i,k,3)*rslopeb(i,k,3)               &
>               ! reduce collection efficiency (suggested by B. Wilt)
>                         *min(max(0.0,qrs(i,k,3)/qci(i,k,1)),1.)**2             &
>                         *qci(i,k,1)*denfac(i,k),qci(i,k,1)/dtcld)
>           endif
> !-------------------------------------------------------------
> ! paacw: Accretion of cloud water by averaged snow/graupel 
> !        (T<T0: C->G or S, and T>=T0: C->R) 
> !-------------------------------------------------------------
>           if(qsum(i,k) .gt. 1.e-15) then
>             paacw(i,k) = (qrs(i,k,2)*psacw(i,k)+qrs(i,k,3)*pgacw(i,k))         & 
>                         /(qsum(i,k))
>           endif      
> !-------------------------------------------------------------
> ! pracs: Accretion of snow by rain [HL A11] [LFO 27]
> !         (T<T0: S->G)
> !-------------------------------------------------------------
>           if(qrs(i,k,2).gt.qcrmin.and.qrs(i,k,1).gt.qcrmin) then
>             if(supcol.gt.0) then
>               acrfac = 5.*rslope3(i,k,2)*rslope3(i,k,2)*rslope(i,k,1)          &
>                       +2.*rslope3(i,k,2)*rslope2(i,k,2)*rslope2(i,k,1)         &
>                       +.5*rslope2(i,k,2)*rslope2(i,k,2)*rslope3(i,k,1)
>               pracs(i,k) = pi**2*n0r*n0s*n0sfac(i,k)*abs(vt2r-vt2ave)          &
>                           *(dens/den(i,k))*acrfac
>               ! reduce collection efficiency (suggested by B. Wilt)
>               pracs(i,k) = pracs(i,k)*min(max(0.0,qrs(i,k,1)/qrs(i,k,2)),1.)**2
>               pracs(i,k) = min(pracs(i,k),qrs(i,k,2)/dtcld)
>             endif
> !-------------------------------------------------------------
> ! psacr: Accretion of rain by snow [HL A10] [LFO 28]
> !         (T<T0:R->S or R->G) (T>=T0: enhance melting of snow)
> !-------------------------------------------------------------
>             acrfac = 5.*rslope3(i,k,1)*rslope3(i,k,1)*rslope(i,k,2)            &
>                     +2.*rslope3(i,k,1)*rslope2(i,k,1)*rslope2(i,k,2)           &
>                     +.5*rslope2(i,k,1)*rslope2(i,k,1)*rslope3(i,k,2)
>             psacr(i,k) = pi**2*n0r*n0s*n0sfac(i,k)*abs(vt2ave-vt2r)            &
>                         *(denr/den(i,k))*acrfac
>               ! reduce collection efficiency (suggested by B. Wilt)
>             psacr(i,k) = psacr(i,k)*min(max(0.0,qrs(i,k,2)/qrs(i,k,1)),1.)**2
>             psacr(i,k) = min(psacr(i,k),qrs(i,k,1)/dtcld)
>           endif
> !-------------------------------------------------------------
> ! pgacr: Accretion of rain by graupel [HL A12] [LFO 42]
> !         (T<T0: R->G) (T>=T0: enhance melting of graupel)
> !-------------------------------------------------------------
>           if(qrs(i,k,3).gt.qcrmin.and.qrs(i,k,1).gt.qcrmin) then
>             acrfac = 5.*rslope3(i,k,1)*rslope3(i,k,1)*rslope(i,k,3)            &
>                     +2.*rslope3(i,k,1)*rslope2(i,k,1)*rslope2(i,k,3)           &
>                     +.5*rslope2(i,k,1)*rslope2(i,k,1)*rslope3(i,k,3)
>             pgacr(i,k) = pi**2*n0r*n0g*abs(vt2ave-vt2r)*(denr/den(i,k))        &
>                         *acrfac
>               ! reduce collection efficiency (suggested by B. Wilt)
>             pgacr(i,k) = pgacr(i,k)*min(max(0.0,qrs(i,k,3)/qrs(i,k,1)),1.)**2
>             pgacr(i,k) = min(pgacr(i,k),qrs(i,k,1)/dtcld)
>           endif
> !
> !-------------------------------------------------------------
> ! pgacs: Accretion of snow by graupel [HL A13] [LFO 29]
> !        (S->G): This process is eliminated in V3.0 with the 
> !        new combined snow/graupel fall speeds
> !-------------------------------------------------------------
>           if(qrs(i,k,3).gt.qcrmin.and.qrs(i,k,2).gt.qcrmin) then
>             pgacs(i,k) = 0.
>           endif
>           if(supcol.le.0) then
>             xlf = xlf0
> !-------------------------------------------------------------
> ! pseml: Enhanced melting of snow by accretion of water [HL A34]
> !        (T>=T0: S->R)
> !-------------------------------------------------------------
>             if(qrs(i,k,2).gt.0.)                                               &
>               pseml(i,k) = min(max(cliq*supcol*(paacw(i,k)+psacr(i,k))         &
>                           /xlf,-qrs(i,k,2)/dtcld),0.)
> !-------------------------------------------------------------
> ! pgeml: Enhanced melting of graupel by accretion of water [HL A24] [RH84 A21-A22]
> !        (T>=T0: G->R)
> !-------------------------------------------------------------
>             if(qrs(i,k,3).gt.0.)                                               &
>               pgeml(i,k) = min(max(cliq*supcol*(paacw(i,k)+pgacr(i,k))         &
>                           /xlf,-qrs(i,k,3)/dtcld),0.)
>           endif
>           if(supcol.gt.0) then
> !-------------------------------------------------------------
739,745c1153,1158
<             if(qci(i,k).gt.0.) then
<               xmi = den(i,k)*qci(i,k)/xni(i,k)
<               diameter = dicon * sqrt(xmi)
<               pisd(i,k) = 4.*diameter*xni(i,k)*(rh(i,k)-1.)/work1(i,k)
<               if(pisd(i,k).lt.0.) then
<                 pisd(i,k) = max(pisd(i,k),satdt/2)
<                 pisd(i,k) = max(pisd(i,k),-qci(i,k)/dtcld)
---
>             if(qci(i,k,2).gt.0.and.ifsat.ne.1) then
>               pidep(i,k) = 4.*diameter*xni(i,k)*(rh(i,k,2)-1.)/work1(i,k,2)
>               supice = satdt-prevp(i,k)
>               if(pidep(i,k).lt.0.) then
>                 pidep(i,k) = max(max(pidep(i,k),satdt/2),supice)
>                 pidep(i,k) = max(pidep(i,k),-qci(i,k,2)/dtcld)
747c1160
<                 pisd(i,k) = min(pisd(i,k),satdt/2)
---
>                 pidep(i,k) = min(min(pidep(i,k),satdt/2),supice)
749c1162
<               if(abs(pisd(i,k)).ge.abs(satdt)) ifsat = 1
---
>               if(abs(prevp(i,k)+pidep(i,k)).ge.abs(satdt)) ifsat = 1
753c1166,1181
< !        (V->S or S->V)
---
> !        (T<T0: V->S or S->V)
> !-------------------------------------------------------------
>             if(qrs(i,k,2).gt.0..and.ifsat.ne.1) then
>               coeres = rslope2(i,k,2)*sqrt(rslope(i,k,2)*rslopeb(i,k,2))
>               psdep(i,k) = (rh(i,k,2)-1.)*n0sfac(i,k)*(precs1*rslope2(i,k,2)   &    
>                            + precs2*work2(i,k)*coeres)/work1(i,k,2)
>               supice = satdt-prevp(i,k)-pidep(i,k)
>               if(psdep(i,k).lt.0.) then
>                 psdep(i,k) = max(psdep(i,k),-qrs(i,k,2)/dtcld)
>                 psdep(i,k) = max(max(psdep(i,k),satdt/2),supice)
>               else
>                 psdep(i,k) = min(min(psdep(i,k),satdt/2),supice)
>               endif
>               if(abs(prevp(i,k)+pidep(i,k)+psdep(i,k)).ge.abs(satdt))          &
>                 ifsat = 1
>             endif
755,762c1183,1193
<             if(qrs(i,k).gt.0..and.ifsat.ne.1) then
<               coeres = rslope2(i,k)*sqrt(rslope(i,k)*rslopeb(i,k))
<               pres(i,k) = (rh(i,k)-1.)*n0sfac(i,k)*(precs1*rslope2(i,k)        &
<                         +precs2*work2(i,k)*coeres)/work1(i,k)
<               supice = satdt-pisd(i,k)
<               if(pres(i,k).lt.0.) then
<                 pres(i,k) = max(pres(i,k),-qrs(i,k)/dtcld)
<                 pres(i,k) = max(max(pres(i,k),satdt/2),supice)
---
> ! pgdep: deposition/sublimation rate of graupel [HL A21] [LFO 46]
> !        (T<T0: V->G or G->V)
> !-------------------------------------------------------------
>             if(qrs(i,k,3).gt.0..and.ifsat.ne.1) then
>               coeres = rslope2(i,k,3)*sqrt(rslope(i,k,3)*rslopeb(i,k,3))
>               pgdep(i,k) = (rh(i,k,2)-1.)*(precg1*rslope2(i,k,3)               &
>                               +precg2*work2(i,k)*coeres)/work1(i,k,2)
>               supice = satdt-prevp(i,k)-pidep(i,k)-psdep(i,k)
>               if(pgdep(i,k).lt.0.) then
>                 pgdep(i,k) = max(pgdep(i,k),-qrs(i,k,3)/dtcld)
>                 pgdep(i,k) = max(max(pgdep(i,k),satdt/2),supice)
764c1195
<                 pres(i,k) = min(min(pres(i,k),satdt/2),supice)
---
>                 pgdep(i,k) = min(min(pgdep(i,k),satdt/2),supice)
766c1197,1198
<               if(abs(pisd(i,k)+pres(i,k)).ge.abs(satdt)) ifsat = 1
---
>               if(abs(prevp(i,k)+pidep(i,k)+psdep(i,k)+pgdep(i,k)).ge.          &
>                 abs(satdt)) ifsat = 1
769c1201
< ! pigen: generation(nucleation) of ice from vapor [HDC 7-8]
---
> ! pigen: generation(nucleation) of ice from vapor [HL 50] [HDC 7-8]
773c1205
<               supice = satdt-pisd(i,k)-pres(i,k)
---
>               supice = satdt-prevp(i,k)-pidep(i,k)-psdep(i,k)-pgdep(i,k)
775,777c1207,1209
<               roqi0 = 4.92e-11*exp(log(xni0)*(1.33))
<               pgen(i,k) = max(0.,(roqi0/den(i,k)-max(qci(i,k),0.))/dtcld)
<               pgen(i,k) = min(min(pgen(i,k),satdt),supice)
---
>               roqi0 = 4.92e-11*xni0**1.33
>               pigen(i,k) = max(0.,(roqi0/den(i,k)-max(qci(i,k,2),0.))/dtcld)
>               pigen(i,k) = min(min(pigen(i,k),satdt),supice)
778a1211
> !
781c1214
< !       (T<T0: I->S)
---
> !        (T<T0: I->S)
783c1216
<             if(qci(i,k).gt.0.) then
---
>             if(qci(i,k,2).gt.0.) then
785c1218,1251
<               paut(i,k) = max(0.,(qci(i,k)-qimax)/dtcld)
---
>               psaut(i,k) = max(0.,(qci(i,k,2)-qimax)/dtcld)
>             endif
> !
> !-------------------------------------------------------------
> ! pgaut: conversion(aggregation) of snow to graupel [HL A4] [LFO 37]
> !        (T<T0: S->G)
> !-------------------------------------------------------------
>             if(qrs(i,k,2).gt.0.) then
>               alpha2 = 1.e-3*exp(0.09*(-supcol))
>               pgaut(i,k) = min(max(0.,alpha2*(qrs(i,k,2)-qs0)),qrs(i,k,2)/dtcld)
>             endif
>           endif
> !
> !-------------------------------------------------------------
> ! psevp: Evaporation of melting snow [HL A35] [RH83 A27]
> !       (T>=T0: S->V)
> !-------------------------------------------------------------
>           if(supcol.lt.0.) then
>             if(qrs(i,k,2).gt.0..and.rh(i,k,1).lt.1.) then
>               coeres = rslope2(i,k,2)*sqrt(rslope(i,k,2)*rslopeb(i,k,2))
>               psevp(i,k) = (rh(i,k,1)-1.)*n0sfac(i,k)*(precs1                  &
>                            *rslope2(i,k,2)+precs2*work2(i,k)                   &
>                            *coeres)/work1(i,k,1)
>               psevp(i,k) = min(max(psevp(i,k),-qrs(i,k,2)/dtcld),0.)
>             endif
> !-------------------------------------------------------------
> ! pgevp: Evaporation of melting graupel [HL A25] [RH84 A19]
> !       (T>=T0: G->V)
> !-------------------------------------------------------------
>             if(qrs(i,k,3).gt.0..and.rh(i,k,1).lt.1.) then
>               coeres = rslope2(i,k,3)*sqrt(rslope(i,k,3)*rslopeb(i,k,3))
>               pgevp(i,k) = (rh(i,k,1)-1.)*(precg1*rslope2(i,k,3)               &
>                          +precg2*work2(i,k)*coeres)/work1(i,k,1)
>               pgevp(i,k) = min(max(pgevp(i,k),-qrs(i,k,3)/dtcld),0.)
790a1257
> !
797,820c1264,1378
<           qciik = max(qmin,qci(i,k))
<           delqci = (paut(i,k)+pacr(i,k)-pgen(i,k)-pisd(i,k))*dtcld
<           if(delqci.ge.qciik) then
<             facqci = qciik/delqci
<             paut(i,k) = paut(i,k)*facqci
<             pacr(i,k) = pacr(i,k)*facqci
<             pgen(i,k) = pgen(i,k)*facqci
<             pisd(i,k) = pisd(i,k)*facqci
<           endif
<           qik = max(qmin,q(i,k))
<           delq = (pres(i,k)+pgen(i,k)+pisd(i,k))*dtcld
<           if(delq.ge.qik) then
<             facq = qik/delq
<             pres(i,k) = pres(i,k)*facq
<             pgen(i,k) = pgen(i,k)*facq
<             pisd(i,k) = pisd(i,k)*facq
<           endif
<           work2(i,k) = -pres(i,k)-pgen(i,k)-pisd(i,k)
<           q(i,k) = q(i,k)+work2(i,k)*dtcld
<           qci(i,k) = max(qci(i,k)-(paut(i,k)+pacr(i,k)-pgen(i,k)-pisd(i,k))    &
<                     *dtcld,0.)
<           qrs(i,k) = max(qrs(i,k)+(paut(i,k)+pacr(i,k)+pres(i,k))*dtcld,0.)
<           if(t(i,k).lt.t0c) then
<             t(i,k) = t(i,k)-xls*work2(i,k)/cpm(i,k)*dtcld
---
> !
>           delta2=0.
>           delta3=0.
>           if(qrs(i,k,1).lt.1.e-4.and.qrs(i,k,2).lt.1.e-4) delta2=1.
>           if(qrs(i,k,1).lt.1.e-4) delta3=1.
>           if(t(i,k).le.t0c) then
> !
> !     cloud water
> !
>             value = max(qmin,qci(i,k,1))
>             source = (praut(i,k)+pracw(i,k)+paacw(i,k)+paacw(i,k))*dtcld
>             if (source.gt.value) then
>               factor = value/source
>               praut(i,k) = praut(i,k)*factor
>               pracw(i,k) = pracw(i,k)*factor
>               paacw(i,k) = paacw(i,k)*factor
>             endif
> !
> !     cloud ice
> !
>             value = max(qmin,qci(i,k,2))
>             source = (psaut(i,k)-pigen(i,k)-pidep(i,k)+praci(i,k)+psaci(i,k)   &     
>                     +pgaci(i,k))*dtcld
>             if (source.gt.value) then
>               factor = value/source
>               psaut(i,k) = psaut(i,k)*factor
>               pigen(i,k) = pigen(i,k)*factor
>               pidep(i,k) = pidep(i,k)*factor
>               praci(i,k) = praci(i,k)*factor
>               psaci(i,k) = psaci(i,k)*factor
>               pgaci(i,k) = pgaci(i,k)*factor
>             endif
> !
> !     rain
> !
>             value = max(qmin,qrs(i,k,1))
>             source = (-praut(i,k)-prevp(i,k)-pracw(i,k)+piacr(i,k)+psacr(i,k)  &    
>                      +pgacr(i,k))*dtcld
>             if (source.gt.value) then
>               factor = value/source
>               praut(i,k) = praut(i,k)*factor
>               prevp(i,k) = prevp(i,k)*factor
>               pracw(i,k) = pracw(i,k)*factor
>               piacr(i,k) = piacr(i,k)*factor
>               psacr(i,k) = psacr(i,k)*factor
>               pgacr(i,k) = pgacr(i,k)*factor
>             endif
> !
> !     snow
> !
>             value = max(qmin,qrs(i,k,2))
>             source = -(psdep(i,k)+psaut(i,k)-pgaut(i,k)+paacw(i,k)+piacr(i,k)  &        
>                      *delta3+praci(i,k)*delta3-pracs(i,k)*(1.-delta2)          &
>                      +psacr(i,k)*delta2+psaci(i,k)-pgacs(i,k) )*dtcld
>             if (source.gt.value) then
>               factor = value/source
>               psdep(i,k) = psdep(i,k)*factor
>               psaut(i,k) = psaut(i,k)*factor
>               pgaut(i,k) = pgaut(i,k)*factor
>               paacw(i,k) = paacw(i,k)*factor
>               piacr(i,k) = piacr(i,k)*factor
>               praci(i,k) = praci(i,k)*factor
>               psaci(i,k) = psaci(i,k)*factor
>               pracs(i,k) = pracs(i,k)*factor
>               psacr(i,k) = psacr(i,k)*factor
>               pgacs(i,k) = pgacs(i,k)*factor
>             endif
> !
> !     graupel
> !
>             value = max(qmin,qrs(i,k,3))
>             source = -(pgdep(i,k)+pgaut(i,k)                                   &
>                      +piacr(i,k)*(1.-delta3)+praci(i,k)*(1.-delta3)            &
>                      +psacr(i,k)*(1.-delta2)+pracs(i,k)*(1.-delta2)            &
>                      +pgaci(i,k)+paacw(i,k)+pgacr(i,k)+pgacs(i,k))*dtcld
>             if (source.gt.value) then
>               factor = value/source
>               pgdep(i,k) = pgdep(i,k)*factor
>               pgaut(i,k) = pgaut(i,k)*factor
>               piacr(i,k) = piacr(i,k)*factor
>               praci(i,k) = praci(i,k)*factor
>               psacr(i,k) = psacr(i,k)*factor
>               pracs(i,k) = pracs(i,k)*factor
>               paacw(i,k) = paacw(i,k)*factor
>               pgaci(i,k) = pgaci(i,k)*factor
>               pgacr(i,k) = pgacr(i,k)*factor
>               pgacs(i,k) = pgacs(i,k)*factor
>             endif
> !
>             work2(i,k)=-(prevp(i,k)+psdep(i,k)+pgdep(i,k)+pigen(i,k)+pidep(i,k))
> !     update
>             q(i,k) = q(i,k)+work2(i,k)*dtcld
>             qci(i,k,1) = max(qci(i,k,1)-(praut(i,k)+pracw(i,k)                 &
>                            +paacw(i,k)+paacw(i,k))*dtcld,0.)
>             qrs(i,k,1) = max(qrs(i,k,1)+(praut(i,k)+pracw(i,k)                 &
>                            +prevp(i,k)-piacr(i,k)-pgacr(i,k)                   &
>                            -psacr(i,k))*dtcld,0.)
>             qci(i,k,2) = max(qci(i,k,2)-(psaut(i,k)+praci(i,k)                 &
>                            +psaci(i,k)+pgaci(i,k)-pigen(i,k)-pidep(i,k))       &
>                            *dtcld,0.)
>             qrs(i,k,2) = max(qrs(i,k,2)+(psdep(i,k)+psaut(i,k)+paacw(i,k)      &
>                            -pgaut(i,k)+piacr(i,k)*delta3                       &
>                            +praci(i,k)*delta3+psaci(i,k)-pgacs(i,k)            &
>                            -pracs(i,k)*(1.-delta2)+psacr(i,k)*delta2)          &
>                            *dtcld,0.)
>             qrs(i,k,3) = max(qrs(i,k,3)+(pgdep(i,k)+pgaut(i,k)                 &
>                            +piacr(i,k)*(1.-delta3)                             &
>                            +praci(i,k)*(1.-delta3)+psacr(i,k)*(1.-delta2)      &
>                            +pracs(i,k)*(1.-delta2)+pgaci(i,k)+paacw(i,k)       &
>                            +pgacr(i,k)+pgacs(i,k))*dtcld,0.)
>             xlf = xls-xl(i,k)
>             xlwork2 = -xls*(psdep(i,k)+pgdep(i,k)+pidep(i,k)+pigen(i,k))       &
>                       -xl(i,k)*prevp(i,k)-xlf*(piacr(i,k)+paacw(i,k)           &
>                       +paacw(i,k)+pgacr(i,k)+psacr(i,k))
>             t(i,k) = t(i,k)-xlwork2/cpm(i,k)*dtcld
822c1380,1443
<             t(i,k) = t(i,k)-xl(i,k)*work2(i,k)/cpm(i,k)*dtcld
---
> !
> !     cloud water
> !
>             value = max(qmin,qci(i,k,1))
>             source=(praut(i,k)+pracw(i,k)+paacw(i,k)+paacw(i,k))*dtcld
>             if (source.gt.value) then
>               factor = value/source
>               praut(i,k) = praut(i,k)*factor
>               pracw(i,k) = pracw(i,k)*factor
>               paacw(i,k) = paacw(i,k)*factor
>             endif
> !
> !     rain
> !
>             value = max(qmin,qrs(i,k,1))
>             source = (-paacw(i,k)-praut(i,k)+pseml(i,k)+pgeml(i,k)-pracw(i,k)  &  
>                      -paacw(i,k)-prevp(i,k))*dtcld
>             if (source.gt.value) then
>               factor = value/source
>               praut(i,k) = praut(i,k)*factor
>               prevp(i,k) = prevp(i,k)*factor
>               pracw(i,k) = pracw(i,k)*factor
>               paacw(i,k) = paacw(i,k)*factor
>               pseml(i,k) = pseml(i,k)*factor
>               pgeml(i,k) = pgeml(i,k)*factor
>             endif
> !
> !     snow
> !
>             value = max(qcrmin,qrs(i,k,2))
>             source=(pgacs(i,k)-pseml(i,k)-psevp(i,k))*dtcld
>             if (source.gt.value) then
>               factor = value/source
>               pgacs(i,k) = pgacs(i,k)*factor
>               psevp(i,k) = psevp(i,k)*factor
>               pseml(i,k) = pseml(i,k)*factor
>             endif
> !
> !     graupel
> !
>             value = max(qcrmin,qrs(i,k,3))
>             source=-(pgacs(i,k)+pgevp(i,k)+pgeml(i,k))*dtcld
>             if (source.gt.value) then
>               factor = value/source
>               pgacs(i,k) = pgacs(i,k)*factor
>               pgevp(i,k) = pgevp(i,k)*factor
>               pgeml(i,k) = pgeml(i,k)*factor
>             endif
>             work2(i,k)=-(prevp(i,k)+psevp(i,k)+pgevp(i,k))
> !     update
>             q(i,k) = q(i,k)+work2(i,k)*dtcld
>             qci(i,k,1) = max(qci(i,k,1)-(praut(i,k)+pracw(i,k)                 &
>                     +paacw(i,k)+paacw(i,k))*dtcld,0.)
>             qrs(i,k,1) = max(qrs(i,k,1)+(praut(i,k)+pracw(i,k)                 &
>                     +prevp(i,k)+paacw(i,k)+paacw(i,k)-pseml(i,k)               &
>                     -pgeml(i,k))*dtcld,0.)
>             qrs(i,k,2) = max(qrs(i,k,2)+(psevp(i,k)-pgacs(i,k)                 &
>                     +pseml(i,k))*dtcld,0.)
>             qrs(i,k,3) = max(qrs(i,k,3)+(pgacs(i,k)+pgevp(i,k)                 &
>                     +pgeml(i,k))*dtcld,0.)
>             xlf = xls-xl(i,k)
>             xlwork2 = -xl(i,k)*(prevp(i,k)+psevp(i,k)+pgevp(i,k))              &
>                       -xlf*(pseml(i,k)+pgeml(i,k))
>             t(i,k) = t(i,k)-xlwork2/cpm(i,k)*dtcld
827,828c1448,1450
<       cvap = cpv
<       hvap = xlv0
---
> ! Inline expansion for fpvs
> !         qs(i,k,1) = fpvs(t(i,k),0,rd,rv,cpv,cliq,cice,xlv0,xls,psat,t0c)
> !         qs(i,k,2) = fpvs(t(i,k),1,rd,rv,cpv,cliq,cice,xlv0,xls,psat,t0c)
829a1452,1453
>       hvap = xlv0
>       cvap = cpv
840,844c1464,1476
<           qs(i,k)=psat*(exp(log(tr)*(xa)))*exp(xb*(1.-tr))
<           qs(i,k) = min(qs(i,k),0.99*p(i,k))
<           qs(i,k) = ep2 * qs(i,k) / (p(i,k) - qs(i,k))
<           qs(i,k) = max(qs(i,k),qmin)
<           denfac(i,k) = sqrt(den0/den(i,k))
---
>           qs(i,k,1)=psat*exp(log(tr)*(xa))*exp(xb*(1.-tr))
>           qs(i,k,1) = min(qs(i,k,1),0.99*p(i,k))
>           qs(i,k,1) = ep2 * qs(i,k,1) / (p(i,k) - qs(i,k,1))
>           qs(i,k,1) = max(qs(i,k,1),qmin)
>           tr=ttp/t(i,k)
>           if(t(i,k).lt.ttp) then
>             qs(i,k,2)=psat*exp(log(tr)*(xai))*exp(xbi*(1.-tr))
>           else
>             qs(i,k,2)=psat*exp(log(tr)*(xa))*exp(xb*(1.-tr))
>           endif
>           qs(i,k,2) = min(qs(i,k,2),0.99*p(i,k))
>           qs(i,k,2) = ep2 * qs(i,k,2) / (p(i,k) - qs(i,k,2))
>           qs(i,k,2) = max(qs(i,k,2),qmin)
855,862c1487,1494
<           work1(i,k) = conden(t(i,k),q(i,k),qs(i,k),xl(i,k),cpm(i,k))
<           work2(i,k) = qci(i,k)+work1(i,k)
<           pcon(i,k) = min(max(work1(i,k),0.),max(q(i,k),0.))/dtcld
<           if(qci(i,k).gt.0..and.work1(i,k).lt.0.and.t(i,k).gt.t0c)             &
<             pcon(i,k) = max(work1(i,k),-qci(i,k))/dtcld
<           q(i,k) = q(i,k)-pcon(i,k)*dtcld
<           qci(i,k) = max(qci(i,k)+pcon(i,k)*dtcld,0.)
<           t(i,k) = t(i,k)+pcon(i,k)*xl(i,k)/cpm(i,k)*dtcld
---
>           work1(i,k,1) = conden(t(i,k),q(i,k),qs(i,k,1),xl(i,k),cpm(i,k))
>           work2(i,k) = qci(i,k,1)+work1(i,k,1)
>           pcond(i,k) = min(max(work1(i,k,1)/dtcld,0.),max(q(i,k),0.)/dtcld)
>           if(qci(i,k,1).gt.0..and.work1(i,k,1).lt.0.)                          &
>             pcond(i,k) = max(work1(i,k,1),-qci(i,k,1))/dtcld
>           q(i,k) = q(i,k)-pcond(i,k)*dtcld
>           qci(i,k,1) = max(qci(i,k,1)+pcond(i,k)*dtcld,0.)
>           t(i,k) = t(i,k)+pcond(i,k)*xl(i,k)/cpm(i,k)*dtcld
865a1498
> !
871,872c1504,1505
<           if(qci(i,k).le.qmin) qci(i,k) = 0.0
<           if(qrs(i,k).le.qcrmin) qrs(i,k) = 0.0
---
>           if(qci(i,k,1).le.qmin) qci(i,k,1) = 0.0
>           if(qci(i,k,2).le.qmin) qci(i,k,2) = 0.0
875d1507
< !
877c1509,1515
<   END SUBROUTINE wsm32D
---
> 
> #ifdef WRF_CHEM
>       rainprod2d = praut+pracw+praci+psaci+pgaci+psacw+pgacw+paacw+psaut
>       evapprod2d = -(prevp+psevp+pgevp+psdep+pgdep)
> #endif
> 
>   END SUBROUTINE wsm62d
925c1563
<   SUBROUTINE wsm3init(den0,denr,dens,cl,cpv,allowed_to_read)
---
>   SUBROUTINE wsm6init(den0,denr,dens,cl,cpv,hail_opt,allowed_to_read)
930a1569
>    INTEGER, INTENT(IN) :: hail_opt  ! RAS
932c1571,1587
< !  
---
> 
> ! RAS13.1 define graupel parameters as graupel-like or hail-like,
> !         depending on namelist option
>       IF (hail_opt .eq. 1) THEN !Hail!
>          n0g       = 4.e4
>          deng      = 700.
>          avtg      = 285.0
>          bvtg      = 0.8
>          lamdagmax = 2.e4
>       ELSE !Graupel!
>          n0g       = 4.e6
>          deng      = 500
>          avtg      = 330.0
>          bvtg      = 0.8
>          lamdagmax = 6.e4
>       ENDIF
> !
935c1590
< !  
---
> !
939c1594
< !  
---
> !
943a1599
>    bvtr6 = 6.+bvtr
946a1603
>    g6pbr = rgmma(bvtr6)
953d1609
<    xmmax = (dimax/dicon)**2
970a1627,1642
>    pacrc = pi*n0s*avts*g3pbs*.25*eacrc
> !
>    bvtg1 = 1.+bvtg
>    bvtg2 = 2.5+.5*bvtg
>    bvtg3 = 3.+bvtg
>    bvtg4 = 4.+bvtg
>    g1pbg = rgmma(bvtg1)
>    g3pbg = rgmma(bvtg3)
>    g4pbg = rgmma(bvtg4)
>    pacrg = pi*n0g*avtg*g3pbg*.25
>    g5pbgo2 = rgmma(bvtg2)
>    pvtg = avtg*g4pbg/6.
>    precg1 = 2.*pi*n0g*.78
>    precg2 = 2.*pi*n0g*.31*avtg**.5*g5pbgo2
>    pidn0g =  pi*deng*n0g
> !
972a1645
>    rslopegmax = 1./lamdagmax
974a1648
>    rslopegbmax = rslopegmax ** bvtg
976a1651
>    rslopeg2max = rslopegmax * rslopegmax
978a1654,1672
>    rslopeg3max = rslopeg2max * rslopegmax
> 
> !+---+-----------------------------------------------------------------+
> !..Set these variables needed for computing radar reflectivity.  These
> !.. get used within radar_init to create other variables used in the
> !.. radar module.
>    xam_r = PI*denr/6.
>    xbm_r = 3.
>    xmu_r = 0.
>    xam_s = PI*dens/6.
>    xbm_s = 3.
>    xmu_s = 0.
>    xam_g = PI*deng/6.
>    xbm_g = 3.
>    xmu_g = 0.
> 
>    call radar_init
> !+---+-----------------------------------------------------------------+
> 
980,982c1674,1677
<   END SUBROUTINE wsm3init
< !
<       subroutine slope_wsm3(qrs,den,denfac,t,rslope,rslopeb,rslope2,rslope3,vt,its,ite,kts,kte)
---
>   END SUBROUTINE wsm6init
> !------------------------------------------------------------------------------
>       subroutine slope_wsm6(qrs,den,denfac,t,rslope,rslopeb,rslope2,rslope3,   &
>                             vt,its,ite,kts,kte)
985c1680
<   REAL, DIMENSION( its:ite , kts:kte ) ::                                      &
---
>   REAL, DIMENSION( its:ite , kts:kte,3) ::                                     &
986a1682,1687
>                                                                        rslope, &
>                                                                       rslopeb, &                                                 
>                                                                       rslope2, &                                                 
>                                                                       rslope3, &                                                 
>                                                                            vt
>   REAL, DIMENSION( its:ite , kts:kte) ::                                       &
989c1690,1758
<                                                                             t, &
---
>                                                                             t
>   REAL, PARAMETER  :: t0c = 273.15
>   REAL, DIMENSION( its:ite , kts:kte ) ::                                      &
>                                                                        n0sfac
>   REAL       ::  lamdar, lamdas, lamdag, x, y, z, supcol
>   integer :: i, j, k
> !----------------------------------------------------------------
> !     size distributions: (x=mixing ratio, y=air density):
> !     valid for mixing ratio > 1.e-9 kg/kg.
>       lamdar(x,y)=   sqrt(sqrt(pidn0r/(x*y)))      ! (pidn0r/(x*y))**.25
>       lamdas(x,y,z)= sqrt(sqrt(pidn0s*z/(x*y)))    ! (pidn0s*z/(x*y))**.25
>       lamdag(x,y)=   sqrt(sqrt(pidn0g/(x*y)))      ! (pidn0g/(x*y))**.25
> !
>       do k = kts, kte
>         do i = its, ite
>           supcol = t0c-t(i,k)
> !---------------------------------------------------------------
> ! n0s: Intercept parameter for snow [m-4] [HDC 6]
> !---------------------------------------------------------------
>           n0sfac(i,k) = max(min(exp(alpha*supcol),n0smax/n0s),1.)
>           if(qrs(i,k,1).le.qcrmin)then
>             rslope(i,k,1) = rslopermax
>             rslopeb(i,k,1) = rsloperbmax
>             rslope2(i,k,1) = rsloper2max
>             rslope3(i,k,1) = rsloper3max
>           else
>             rslope(i,k,1) = 1./lamdar(qrs(i,k,1),den(i,k))
>             rslopeb(i,k,1) = rslope(i,k,1)**bvtr
>             rslope2(i,k,1) = rslope(i,k,1)*rslope(i,k,1)
>             rslope3(i,k,1) = rslope2(i,k,1)*rslope(i,k,1)
>           endif
>           if(qrs(i,k,2).le.qcrmin)then
>             rslope(i,k,2) = rslopesmax
>             rslopeb(i,k,2) = rslopesbmax
>             rslope2(i,k,2) = rslopes2max
>             rslope3(i,k,2) = rslopes3max
>           else
>             rslope(i,k,2) = 1./lamdas(qrs(i,k,2),den(i,k),n0sfac(i,k))
>             rslopeb(i,k,2) = rslope(i,k,2)**bvts
>             rslope2(i,k,2) = rslope(i,k,2)*rslope(i,k,2)
>             rslope3(i,k,2) = rslope2(i,k,2)*rslope(i,k,2)
>           endif
>           if(qrs(i,k,3).le.qcrmin)then
>             rslope(i,k,3) = rslopegmax
>             rslopeb(i,k,3) = rslopegbmax
>             rslope2(i,k,3) = rslopeg2max
>             rslope3(i,k,3) = rslopeg3max
>           else
>             rslope(i,k,3) = 1./lamdag(qrs(i,k,3),den(i,k))
>             rslopeb(i,k,3) = rslope(i,k,3)**bvtg
>             rslope2(i,k,3) = rslope(i,k,3)*rslope(i,k,3)
>             rslope3(i,k,3) = rslope2(i,k,3)*rslope(i,k,3)
>           endif
>           vt(i,k,1) = pvtr*rslopeb(i,k,1)*denfac(i,k)
>           vt(i,k,2) = pvts*rslopeb(i,k,2)*denfac(i,k)
>           vt(i,k,3) = pvtg*rslopeb(i,k,3)*denfac(i,k)
>           if(qrs(i,k,1).le.0.0) vt(i,k,1) = 0.0
>           if(qrs(i,k,2).le.0.0) vt(i,k,2) = 0.0
>           if(qrs(i,k,3).le.0.0) vt(i,k,3) = 0.0
>         enddo
>       enddo
>   END subroutine slope_wsm6
> !-----------------------------------------------------------------------------
>       subroutine slope_rain(qrs,den,denfac,t,rslope,rslopeb,rslope2,rslope3,   & 
>                             vt,its,ite,kts,kte)
>   IMPLICIT NONE
>   INTEGER       ::               its,ite, jts,jte, kts,kte
>   REAL, DIMENSION( its:ite , kts:kte) ::                                       &
>                                                                           qrs, &
994c1763,1766
<                                                                            vt
---
>                                                                            vt, &      
>                                                                           den, &
>                                                                        denfac, &
>                                                                             t
998c1770
<   REAL       ::  lamdar,lamdas,x, y, z, supcol, pvt
---
>   REAL       ::  lamdar, x, y, z, supcol
1003d1774
< !
1004a1776,1817
> !
>       do k = kts, kte
>         do i = its, ite
>           if(qrs(i,k).le.qcrmin)then
>             rslope(i,k) = rslopermax
>             rslopeb(i,k) = rsloperbmax
>             rslope2(i,k) = rsloper2max
>             rslope3(i,k) = rsloper3max
>           else
>             rslope(i,k) = 1./lamdar(qrs(i,k),den(i,k))
>             rslopeb(i,k) = rslope(i,k)**bvtr
>             rslope2(i,k) = rslope(i,k)*rslope(i,k)
>             rslope3(i,k) = rslope2(i,k)*rslope(i,k)
>           endif
>           vt(i,k) = pvtr*rslopeb(i,k)*denfac(i,k)
>           if(qrs(i,k).le.0.0) vt(i,k) = 0.0
>         enddo
>       enddo
>   END subroutine slope_rain
> !------------------------------------------------------------------------------
>       subroutine slope_snow(qrs,den,denfac,t,rslope,rslopeb,rslope2,rslope3,   &
>                             vt,its,ite,kts,kte)
>   IMPLICIT NONE
>   INTEGER       ::               its,ite, jts,jte, kts,kte
>   REAL, DIMENSION( its:ite , kts:kte) ::                                       &
>                                                                           qrs, &
>                                                                        rslope, &
>                                                                       rslopeb, &
>                                                                       rslope2, &
>                                                                       rslope3, &
>                                                                            vt, &  
>                                                                           den, &
>                                                                        denfac, &
>                                                                             t
>   REAL, PARAMETER  :: t0c = 273.15
>   REAL, DIMENSION( its:ite , kts:kte ) ::                                      &
>                                                                        n0sfac
>   REAL       ::  lamdas, x, y, z, supcol
>   integer :: i, j, k
> !----------------------------------------------------------------
> !     size distributions: (x=mixing ratio, y=air density):
> !     valid for mixing ratio > 1.e-9 kg/kg.
1009,1021c1822,1831
<           if(t(i,k).ge.t0c) then
<             pvt = pvtr
<             if(qrs(i,k).le.qcrmin)then
<               rslope(i,k) = rslopermax
<               rslopeb(i,k) = rsloperbmax
<               rslope2(i,k) = rsloper2max
<               rslope3(i,k) = rsloper3max
<             else
<               rslope(i,k) = 1./lamdar(qrs(i,k),den(i,k))
<               rslopeb(i,k) = exp(log(rslope(i,k))*(bvtr))
<               rslope2(i,k) = rslope(i,k)*rslope(i,k)
<               rslope3(i,k) = rslope2(i,k)*rslope(i,k)
<             endif
---
>           supcol = t0c-t(i,k)
> !---------------------------------------------------------------
> ! n0s: Intercept parameter for snow [m-4] [HDC 6]
> !---------------------------------------------------------------
>           n0sfac(i,k) = max(min(exp(alpha*supcol),n0smax/n0s),1.)
>           if(qrs(i,k).le.qcrmin)then
>             rslope(i,k) = rslopesmax
>             rslopeb(i,k) = rslopesbmax
>             rslope2(i,k) = rslopes2max
>             rslope3(i,k) = rslopes3max
1023,1036c1833,1836
<             supcol = t0c-t(i,k)
<             n0sfac(i,k) = max(min(exp(alpha*supcol),n0smax/n0s),1.)
<             pvt = pvts
<             if(qrs(i,k).le.qcrmin)then
<               rslope(i,k) = rslopesmax
<               rslopeb(i,k) = rslopesbmax
<               rslope2(i,k) = rslopes2max
<               rslope3(i,k) = rslopes3max
<             else
<               rslope(i,k) = 1./lamdas(qrs(i,k),den(i,k),n0sfac(i,k))
<               rslopeb(i,k) = exp(log(rslope(i,k))*(bvts))
<               rslope2(i,k) = rslope(i,k)*rslope(i,k)
<               rslope3(i,k) = rslope2(i,k)*rslope(i,k)
<             endif
---
>             rslope(i,k) = 1./lamdas(qrs(i,k),den(i,k),n0sfac(i,k))
>             rslopeb(i,k) = rslope(i,k)**bvts
>             rslope2(i,k) = rslope(i,k)*rslope(i,k)
>             rslope3(i,k) = rslope2(i,k)*rslope(i,k)
1038c1838
<           vt(i,k) = pvt*rslopeb(i,k)*denfac(i,k)
---
>           vt(i,k) = pvts*rslopeb(i,k)*denfac(i,k)
1042c1842,1889
<   END subroutine slope_wsm3
---
>   END subroutine slope_snow
> !----------------------------------------------------------------------------------
>       subroutine slope_graup(qrs,den,denfac,t,rslope,rslopeb,rslope2,rslope3,   &
>                             vt,its,ite,kts,kte)
>   IMPLICIT NONE
>   INTEGER       ::               its,ite, jts,jte, kts,kte
>   REAL, DIMENSION( its:ite , kts:kte) ::                                       &
>                                                                           qrs, &
>                                                                        rslope, &
>                                                                       rslopeb, &
>                                                                       rslope2, &
>                                                                       rslope3, &
>                                                                            vt, &  
>                                                                           den, &
>                                                                        denfac, &
>                                                                             t
>   REAL, PARAMETER  :: t0c = 273.15
>   REAL, DIMENSION( its:ite , kts:kte ) ::                                      &
>                                                                        n0sfac
>   REAL       ::  lamdag, x, y, z, supcol
>   integer :: i, j, k
> !----------------------------------------------------------------
> !     size distributions: (x=mixing ratio, y=air density):
> !     valid for mixing ratio > 1.e-9 kg/kg.
>       lamdag(x,y)=   sqrt(sqrt(pidn0g/(x*y)))      ! (pidn0g/(x*y))**.25
> !
>       do k = kts, kte
>         do i = its, ite
> !---------------------------------------------------------------
> ! n0s: Intercept parameter for snow [m-4] [HDC 6]
> !---------------------------------------------------------------
>           if(qrs(i,k).le.qcrmin)then
>             rslope(i,k) = rslopegmax
>             rslopeb(i,k) = rslopegbmax
>             rslope2(i,k) = rslopeg2max
>             rslope3(i,k) = rslopeg3max
>           else
>             rslope(i,k) = 1./lamdag(qrs(i,k),den(i,k))
>             rslopeb(i,k) = rslope(i,k)**bvtg
>             rslope2(i,k) = rslope(i,k)*rslope(i,k)
>             rslope3(i,k) = rslope2(i,k)*rslope(i,k)
>           endif
>           vt(i,k) = pvtg*rslopeb(i,k)*denfac(i,k)
>           if(qrs(i,k).le.0.0) vt(i,k) = 0.0
>         enddo
>       enddo
>   END subroutine slope_graup
> !---------------------------------------------------------------------------------
1044c1891
<       SUBROUTINE nislfv_rain_pcm(im,km,denl,denfacl,tkl,dzl,wwl,rql,precip,dt,id,iter)
---
>       SUBROUTINE nislfv_rain_plm(im,km,denl,denfacl,tkl,dzl,wwl,rql,precip,dt,id,iter)
1059,1060c1906,1907
< !        0 : use departure wind for advection 
< !        1 : use mean wind for advection 
---
> !        0 : use departure wind for advection
> !        1 : use mean wind for advection
1076d1922
<       real  zsumt,qsumt,zsumb,qsumb
1113c1959
< ! pcm is 1st order, we should use 2nd order wi
---
> ! plm is 2nd order, we can use 2nd order wi or 3rd order wi
1115a1962
>       wi(km+1) = ww(km)
1118a1966,1974
> ! 3rd order interpolation to get wi
>       fa1 = 9./16.
>       fa2 = 1./16.
>       wi(1) = ww(1)
>       wi(2) = 0.5*(ww(2)+ww(1))
>       do k=3,km-1
>         wi(k) = fa1*(ww(k)+ww(k-1))-fa2*(ww(k+1)+ww(k-2))
>       enddo
>       wi(km) = 0.5*(ww(km)+ww(km-1))
1155,1156c2011,2012
<         call slope_wsm3(qr,den,denfac,tk,tmp,tmp1,tmp2,tmp3,wa,1,1,1,km)
<         if( n.eq.2 ) wa(1:km) = 0.5*(wa(1:km)+was(1:km))
---
>         call slope_rain(qr,den,denfac,tk,tmp,tmp1,tmp2,tmp3,wa,1,1,1,km)
>         if( n.ge.2 ) wa(1:km)=0.5*(wa(1:km)+was(1:km))
1159c2015
< !      print*,' slope_wsm3 ',qr(k)*1000.,den(k),denfac(k),tk(k),tmp(k),tmp1(k),tmp2(k),ww(k),wa(k)
---
> !        print*,' slope_wsm3 ',qr(k)*1000.,den(k),denfac(k),tk(k),tmp(k),tmp1(k),tmp2(k),ww(k),wa(k)
1168a2025,2044
> ! estimate values at arrival cell interface with monotone
>       do k=2,km
>         dip=(qa(k+1)-qa(k))/(dza(k+1)+dza(k))
>         dim=(qa(k)-qa(k-1))/(dza(k-1)+dza(k))
>         if( dip*dim.le.0.0 ) then
>           qmi(k)=qa(k)
>           qpi(k)=qa(k)
>         else
>           qpi(k)=qa(k)+0.5*(dip+dim)*dza(k)
>           qmi(k)=2.0*qa(k)-qpi(k)
>           if( qpi(k).lt.0.0 .or. qmi(k).lt.0.0 ) then
>             qpi(k) = qa(k)
>             qmi(k) = qa(k)
>           endif
>         endif
>       enddo
>       qpi(1)=qa(1)
>       qmi(1)=qa(1)
>       qmi(km+1)=qa(km+1)
>       qpi(km+1)=qa(km+1)
1196a2073
>                kt = kt - 1
1198,1209c2075,2093
<                if( kt-kb.eq.1 ) then
<                  qn(k) = qa(kb)
<                else if( kt-kb.ge.2 ) then
<                  zsumb = za(kb+1)-zi(k)
<                  qsumb = qa(kb) * zsumb
<                  zsumt = zi(k+1)-za(kt-1)
<                  qsumt = qa(kt-1) * zsumt
<                  qsum = 0.0
<                  zsum = 0.0
<                  if( kt-kb.ge.3 ) then
<                  do m=kb+1,kt-2
<                    qsum = qsum + qa(m) * dza(m)
---
>                if( kt.eq.kb ) then
>                  tl=(zi(k)-za(kb))/dza(kb)
>                  th=(zi(k+1)-za(kb))/dza(kb)
>                  tl2=tl*tl
>                  th2=th*th
>                  qqd=0.5*(qpi(kb)-qmi(kb))
>                  qqh=qqd*th2+qmi(kb)*th
>                  qql=qqd*tl2+qmi(kb)*tl
>                  qn(k) = (qqh-qql)/(th-tl)
>                else if( kt.gt.kb ) then
>                  tl=(zi(k)-za(kb))/dza(kb)
>                  tl2=tl*tl
>                  qqd=0.5*(qpi(kb)-qmi(kb))
>                  qql=qqd*tl2+qmi(kb)*tl
>                  dql = qa(kb)-qql
>                  zsum  = (1.-tl)*dza(kb)
>                  qsum  = dql*dza(kb)
>                  if( kt-kb.gt.1 ) then
>                  do m=kb+1,kt-1
1210a2095
>                    qsum = qsum + qa(m) * dza(m)
1213c2098,2104
<                  qn(k) = (qsumb+qsum+qsumt)/(zsumb+zsum+zsumt)
---
>                  th=(zi(k+1)-za(kt))/dza(kt)
>                  th2=th*th
>                  qqd=0.5*(qpi(kt)-qmi(kt))
>                  dqh=qqd*th2+qmi(kt)*th
>                  zsum  = zsum + th*dza(kt)
>                  qsum  = qsum + dqh*dza(kt)
>                  qn(k) = qsum/zsum
1238c2129
<   END SUBROUTINE nislfv_rain_pcm
---
>   END SUBROUTINE nislfv_rain_plm
1240c2131
<       SUBROUTINE nislfv_rain_plm(im,km,denl,denfacl,tkl,dzl,wwl,rql,precip,dt,id,iter)
---
>       SUBROUTINE nislfv_rain_plm6(im,km,denl,denfacl,tkl,dzl,wwl,rql,rql2, precip1, precip2,dt,id,iter)
1255,1256c2146,2147
< !        0 : use departure wind for advection 
< !        1 : use mean wind for advection 
---
> !        0 : use departure wind for advection
> !        1 : use mean wind for advection
1265c2156
<       real  dzl(im,km),wwl(im,km),rql(im,km),precip(im)
---
>       real  dzl(im,km),wwl(im,km),rql(im,km),rql2(im,km),precip(im),precip1(im),precip2(im)
1268c2159
<       integer  i,k,n,m,kk,kb,kt,iter
---
>       integer  i,k,n,m,kk,kb,kt,iter,ist
1273c2164
<       real  dz(km), ww(km), qq(km), wd(km), wa(km), was(km)
---
>       real  dz(km), ww(km), qq(km), qq2(km), wd(km), wa(km), wa2(km), was(km)
1276,1277c2167,2168
<       real  qn(km), qr(km),tmp(km),tmp1(km),tmp2(km),tmp3(km)
<       real  dza(km+1), qa(km+1), qmi(km+1), qpi(km+1)
---
>       real  qn(km), qr(km),qr2(km),tmp(km),tmp1(km),tmp2(km),tmp3(km)
>       real  dza(km+1), qa(km+1), qa2(km+1),qmi(km+1), qpi(km+1)
1279a2171,2172
>       precip1(:) = 0.0
>       precip2(:) = 0.0
1284a2178
>       qq2(:) = rql2(i,:)
1292c2186
<         allold = allold + qq(k)
---
>         allold = allold + qq(k) + qq2(k)
1351a2246
>         qa2(k) = qq2(k)*dz(k)/dza(k)
1352a2248
>         qr2(k) = qa2(k)/den(k)
1354a2251
>       qa2(km+1) = 0.0
1360c2257,2266
<         call slope_wsm3(qr,den,denfac,tk,tmp,tmp1,tmp2,tmp3,wa,1,1,1,km)
---
>         call slope_snow(qr,den,denfac,tk,tmp,tmp1,tmp2,tmp3,wa,1,1,1,km)
>         call slope_graup(qr2,den,denfac,tk,tmp,tmp1,tmp2,tmp3,wa2,1,1,1,km)
>         do k = 1, km
>           tmp(k) = max((qr(k)+qr2(k)), 1.E-15)
>           IF ( tmp(k) .gt. 1.e-15 ) THEN
>             wa(k) = (wa(k)*qr(k) + wa2(k)*qr2(k))/tmp(k)
>           ELSE
>             wa(k) = 0.
>           ENDIF
>         enddo
1364c2270,2271
< !        print*,' slope_wsm3 ',qr(k)*1000.,den(k),denfac(k),tk(k),tmp(k),tmp1(k),tmp2(k),ww(k),wa(k)
---
> !        print*,' slope_wsm3 ',qr(k)*1000.,den(k),denfac(k),tk(k),tmp(k),tmp1(k),tmp2(k), &
> !           ww(k),wa(k)
1372a2280,2285
>       ist_loop : do ist = 1, 2
>       if (ist.eq.2) then
>        qa(:) = qa2(:)
>       endif
> !
>       precip(i) = 0.
1473c2386,2393
<       rql(i,:) = qn(:)
---
>       if(ist.eq.1) then
>         rql(i,:) = qn(:)
>         precip1(i) = precip(i)
>       else
>         rql2(i,:) = qn(:)
>         precip2(i) = precip(i)
>       endif
>       enddo ist_loop
1478,1479c2398,2576
<   END SUBROUTINE nislfv_rain_plm
< !
---
>   END SUBROUTINE nislfv_rain_plm6
> 
> !+---+-----------------------------------------------------------------+
> 
>       subroutine refl10cm_wsm6 (qv1d, qr1d, qs1d, qg1d,                 &
>                        t1d, p1d, dBZ, kts, kte, ii, jj)
> 
>       IMPLICIT NONE
> 
> !..Sub arguments
>       INTEGER, INTENT(IN):: kts, kte, ii, jj
>       REAL, DIMENSION(kts:kte), INTENT(IN)::                            &
>                       qv1d, qr1d, qs1d, qg1d, t1d, p1d
>       REAL, DIMENSION(kts:kte), INTENT(INOUT):: dBZ
> 
> !..Local variables
>       REAL, DIMENSION(kts:kte):: temp, pres, qv, rho
>       REAL, DIMENSION(kts:kte):: rr, rs, rg
>       REAL:: temp_C
> 
>       DOUBLE PRECISION, DIMENSION(kts:kte):: ilamr, ilams, ilamg
>       DOUBLE PRECISION, DIMENSION(kts:kte):: N0_r, N0_s, N0_g
>       DOUBLE PRECISION:: lamr, lams, lamg
>       LOGICAL, DIMENSION(kts:kte):: L_qr, L_qs, L_qg
> 
>       REAL, DIMENSION(kts:kte):: ze_rain, ze_snow, ze_graupel
>       DOUBLE PRECISION:: fmelt_s, fmelt_g
> 
>       INTEGER:: i, k, k_0, kbot, n
>       LOGICAL:: melti
> 
>       DOUBLE PRECISION:: cback, x, eta, f_d
>       REAL, PARAMETER:: R=287.
> 
> !+---+
> 
>       do k = kts, kte
>          dBZ(k) = -35.0
>       enddo
> 
> !+---+-----------------------------------------------------------------+
> !..Put column of data into local arrays.
> !+---+-----------------------------------------------------------------+
>       do k = kts, kte
>          temp(k) = t1d(k)
>          temp_C = min(-0.001, temp(K)-273.15)
>          qv(k) = MAX(1.E-10, qv1d(k))
>          pres(k) = p1d(k)
>          rho(k) = 0.622*pres(k)/(R*temp(k)*(qv(k)+0.622))
> 
>          if (qr1d(k) .gt. 1.E-9) then
>             rr(k) = qr1d(k)*rho(k)
>             N0_r(k) = n0r
>             lamr = (xam_r*xcrg(3)*N0_r(k)/rr(k))**(1./xcre(1))
>             ilamr(k) = 1./lamr
>             L_qr(k) = .true.
>          else
>             rr(k) = 1.E-12
>             L_qr(k) = .false.
>          endif
> 
>          if (qs1d(k) .gt. 1.E-9) then
>             rs(k) = qs1d(k)*rho(k)
>             N0_s(k) = min(n0smax, n0s*exp(-alpha*temp_C))
>             lams = (xam_s*xcsg(3)*N0_s(k)/rs(k))**(1./xcse(1))
>             ilams(k) = 1./lams
>             L_qs(k) = .true.
>          else
>             rs(k) = 1.E-12
>             L_qs(k) = .false.
>          endif
> 
>          if (qg1d(k) .gt. 1.E-9) then
>             rg(k) = qg1d(k)*rho(k)
>             N0_g(k) = n0g
>             lamg = (xam_g*xcgg(3)*N0_g(k)/rg(k))**(1./xcge(1))
>             ilamg(k) = 1./lamg
>             L_qg(k) = .true.
>          else
>             rg(k) = 1.E-12
>             L_qg(k) = .false.
>          endif
>       enddo
> 
> !+---+-----------------------------------------------------------------+
> !..Locate K-level of start of melting (k_0 is level above).
> !+---+-----------------------------------------------------------------+
>       melti = .false.
>       k_0 = kts
>       do k = kte-1, kts, -1
>          if ( (temp(k).gt.273.15) .and. L_qr(k)                         &
>                                   .and. (L_qs(k+1).or.L_qg(k+1)) ) then
>             k_0 = MAX(k+1, k_0)
>             melti=.true.
>             goto 195
>          endif
>       enddo
>  195  continue
> 
> !+---+-----------------------------------------------------------------+
> !..Assume Rayleigh approximation at 10 cm wavelength. Rain (all temps)
> !.. and non-water-coated snow and graupel when below freezing are
> !.. simple. Integrations of m(D)*m(D)*N(D)*dD.
> !+---+-----------------------------------------------------------------+
> 
>       do k = kts, kte
>          ze_rain(k) = 1.e-22
>          ze_snow(k) = 1.e-22
>          ze_graupel(k) = 1.e-22
>          if (L_qr(k)) ze_rain(k) = N0_r(k)*xcrg(4)*ilamr(k)**xcre(4)
>          if (L_qs(k)) ze_snow(k) = (0.176/0.93) * (6.0/PI)*(6.0/PI)     &
>                                  * (xam_s/900.0)*(xam_s/900.0)          &
>                                  * N0_s(k)*xcsg(4)*ilams(k)**xcse(4)
>          if (L_qg(k)) ze_graupel(k) = (0.176/0.93) * (6.0/PI)*(6.0/PI)  &
>                                     * (xam_g/900.0)*(xam_g/900.0)       &
>                                     * N0_g(k)*xcgg(4)*ilamg(k)**xcge(4)
>       enddo
> 
> 
> !+---+-----------------------------------------------------------------+
> !..Special case of melting ice (snow/graupel) particles.  Assume the
> !.. ice is surrounded by the liquid water.  Fraction of meltwater is
> !.. extremely simple based on amount found above the melting level.
> !.. Uses code from Uli Blahak (rayleigh_soak_wetgraupel and supporting
> !.. routines).
> !+---+-----------------------------------------------------------------+
> 
>       if (melti .and. k_0.ge.kts+1) then
>        do k = k_0-1, kts, -1
> 
> !..Reflectivity contributed by melting snow
>           if (L_qs(k) .and. L_qs(k_0) ) then
>            fmelt_s = MAX(0.005d0, MIN(1.0d0-rs(k)/rs(k_0), 0.99d0))
>            eta = 0.d0
>            lams = 1./ilams(k)
>            do n = 1, nrbins
>               x = xam_s * xxDs(n)**xbm_s
>               call rayleigh_soak_wetgraupel (x,DBLE(xocms),DBLE(xobms), &
>                     fmelt_s, melt_outside_s, m_w_0, m_i_0, lamda_radar, &
>                     CBACK, mixingrulestring_s, matrixstring_s,          &
>                     inclusionstring_s, hoststring_s,                    &
>                     hostmatrixstring_s, hostinclusionstring_s)
>               f_d = N0_s(k)*xxDs(n)**xmu_s * DEXP(-lams*xxDs(n))
>               eta = eta + f_d * CBACK * simpson(n) * xdts(n)
>            enddo
>            ze_snow(k) = SNGL(lamda4 / (pi5 * K_w) * eta)
>           endif
> 
> 
> !..Reflectivity contributed by melting graupel
> 
>           if (L_qg(k) .and. L_qg(k_0) ) then
>            fmelt_g = MAX(0.005d0, MIN(1.0d0-rg(k)/rg(k_0), 0.99d0))
>            eta = 0.d0
>            lamg = 1./ilamg(k)
>            do n = 1, nrbins
>               x = xam_g * xxDg(n)**xbm_g
>               call rayleigh_soak_wetgraupel (x,DBLE(xocmg),DBLE(xobmg), &
>                     fmelt_g, melt_outside_g, m_w_0, m_i_0, lamda_radar, &
>                     CBACK, mixingrulestring_g, matrixstring_g,          &
>                     inclusionstring_g, hoststring_g,                    &
>                     hostmatrixstring_g, hostinclusionstring_g)
>               f_d = N0_g(k)*xxDg(n)**xmu_g * DEXP(-lamg*xxDg(n))
>               eta = eta + f_d * CBACK * simpson(n) * xdtg(n)
>            enddo
>            ze_graupel(k) = SNGL(lamda4 / (pi5 * K_w) * eta)
>           endif
> 
>        enddo
>       endif
> 
>       do k = kte, kts, -1
>          dBZ(k) = 10.*log10((ze_rain(k)+ze_snow(k)+ze_graupel(k))*1.d18)
>       enddo
> 
> 
>       end subroutine refl10cm_wsm6
> !+---+-----------------------------------------------------------------+
> 
1481c2578
<      subroutine effectRad_wsm3 (t, qc, qi, qs, rho, qmin, t0c,        &
---
>      subroutine effectRad_wsm6 (t, qc, qi, qs, rho, qmin, t0c,        &
1551c2648
<           lamdac   = (pidnc*nc0/rqc(k))**obmr
---
>           lamdac   = (pidnc*nc0/rqc(k))**obmr 
1574c2671
<       end subroutine effectRad_wsm3
---
>       end subroutine effectRad_wsm6
1576,1577c2673,2674
< END MODULE module_mp_wsm3
< #endif
---
> 
> END MODULE module_mp_wsm6
